
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="8-x.html">
      
      
      
      <link rel="icon" href="assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.0, mkdocs-material-9.5.31">
    
    
      
        <title>Chap 9 Graph Algorithm - ZIJI-CS-FundamentalDataStructure</title>
      
    
    
      <link rel="stylesheet" href="assets/stylesheets/main.3cba04c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="supports/css/base.css">
    
      <link rel="stylesheet" href="supports/css/theme.css">
    
      <link rel="stylesheet" href="supports/css/admonitions.css">
    
      <link rel="stylesheet" href="supports/css/custom-adms.css">
    
      <link rel="stylesheet" href="https://jsd.cdn.zzko.cn/npm/katex@0.16.4/dist/katex.min.css">
    
    <script>__md_scope=new URL(".",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
    html.glightbox-open { overflow: initial; height: 100%; }
    .gslide-title { margin-top: 0px; user-select: text; }
    .gslide-desc { color: #666; user-select: text; }
    .gslide-image img { background: white; }
    .gscrollbar-fixer { padding-right: 15px; }
    .gdesc-inner { font-size: 0.75rem; }
    body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
    body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
    body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}</style> <script src="assets/javascripts/glightbox.min.js"></script></head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#chap-9-graph-algorithm" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="." title="ZIJI-CS-FundamentalDataStructure" class="md-header__button md-logo" aria-label="ZIJI-CS-FundamentalDataStructure" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            ZIJI-CS-FundamentalDataStructure
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Chap 9 Graph Algorithm
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
          <a href="javascript:void(0)" class="md-search__icon md-icon" title="分享" aria-label="分享" data-clipboard data-clipboard-text="" data-md-component="search-share" tabindex="-1">
            
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08Z"/></svg>
          </a>
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/ZIJI-CS/T-FundamentalDataStructure" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 480 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M186.1 328.7c0 20.9-10.9 55.1-36.7 55.1s-36.7-34.2-36.7-55.1 10.9-55.1 36.7-55.1 36.7 34.2 36.7 55.1zM480 278.2c0 31.9-3.2 65.7-17.5 95-37.9 76.6-142.1 74.8-216.7 74.8-75.8 0-186.2 2.7-225.6-74.8-14.6-29-20.2-63.1-20.2-95 0-41.9 13.9-81.5 41.5-113.6-5.2-15.8-7.7-32.4-7.7-48.8 0-21.5 4.9-32.3 14.6-51.8 45.3 0 74.3 9 108.8 36 29-6.9 58.8-10 88.7-10 27 0 54.2 2.9 80.4 9.2 34-26.7 63-35.2 107.8-35.2 9.8 19.5 14.6 30.3 14.6 51.8 0 16.4-2.6 32.7-7.7 48.2 27.5 32.4 39 72.3 39 114.2zm-64.3 50.5c0-43.9-26.7-82.6-73.5-82.6-18.9 0-37 3.4-56 6-14.9 2.3-29.8 3.2-45.1 3.2-15.2 0-30.1-.9-45.1-3.2-18.7-2.6-37-6-56-6-46.8 0-73.5 38.7-73.5 82.6 0 87.8 80.4 101.3 150.4 101.3h48.2c70.3 0 150.6-13.4 150.6-101.3zm-82.6-55.1c-25.8 0-36.7 34.2-36.7 55.1s10.9 55.1 36.7 55.1 36.7-34.2 36.7-55.1-10.9-55.1-36.7-55.1z"/></svg>
  </div>
  <div class="md-source__repository">
    ZIJI-CS/T-FundamentalDataStructure
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href="https://ziji-cs.github.io/" class="md-tabs__link">
        
  
    
  
  Home

      </a>
    </li>
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="index.html" class="md-tabs__link">
          
  
    
  
  Main

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="." title="ZIJI-CS-FundamentalDataStructure" class="md-nav__button md-logo" aria-label="ZIJI-CS-FundamentalDataStructure" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    ZIJI-CS-FundamentalDataStructure
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/ZIJI-CS/T-FundamentalDataStructure" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 480 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M186.1 328.7c0 20.9-10.9 55.1-36.7 55.1s-36.7-34.2-36.7-55.1 10.9-55.1 36.7-55.1 36.7 34.2 36.7 55.1zM480 278.2c0 31.9-3.2 65.7-17.5 95-37.9 76.6-142.1 74.8-216.7 74.8-75.8 0-186.2 2.7-225.6-74.8-14.6-29-20.2-63.1-20.2-95 0-41.9 13.9-81.5 41.5-113.6-5.2-15.8-7.7-32.4-7.7-48.8 0-21.5 4.9-32.3 14.6-51.8 45.3 0 74.3 9 108.8 36 29-6.9 58.8-10 88.7-10 27 0 54.2 2.9 80.4 9.2 34-26.7 63-35.2 107.8-35.2 9.8 19.5 14.6 30.3 14.6 51.8 0 16.4-2.6 32.7-7.7 48.2 27.5 32.4 39 72.3 39 114.2zm-64.3 50.5c0-43.9-26.7-82.6-73.5-82.6-18.9 0-37 3.4-56 6-14.9 2.3-29.8 3.2-45.1 3.2-15.2 0-30.1-.9-45.1-3.2-18.7-2.6-37-6-56-6-46.8 0-73.5 38.7-73.5 82.6 0 87.8 80.4 101.3 150.4 101.3h48.2c70.3 0 150.6-13.4 150.6-101.3zm-82.6-55.1c-25.8 0-36.7 34.2-36.7 55.1s10.9 55.1 36.7 55.1 36.7-34.2 36.7-55.1-10.9-55.1-36.7-55.1z"/></svg>
  </div>
  <div class="md-source__repository">
    ZIJI-CS/T-FundamentalDataStructure
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="https://ziji-cs.github.io/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          
          <div class="md-nav__link md-nav__container">
            <a href="index.html" class="md-nav__link ">
              
  
  <span class="md-ellipsis">
    Main
  </span>
  

            </a>
            
              
              <label class="md-nav__link " for="__nav_2" id="__nav_2_label" tabindex="">
                <span class="md-nav__icon md-icon"></span>
              </label>
            
          </div>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Main
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="2-x.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chap 2 Algorithm Analysis
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="3-x.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chap 3 Lists, Stacks, and Queues
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="4-x.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chap 4 Trees
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="5-x.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chap 5 Hashing
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="6-x.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chap 6 Priority Queues(Heaps)
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="7-x.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chap 7 Sorting
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="8-x.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Chap 8 The Disjoint Set ADT
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Chap 9 Graph Algorithm
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="9-x.html" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Chap 9 Graph Algorithm
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#definitions" class="md-nav__link">
    <span class="md-ellipsis">
      Definitions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Definitions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#representation-of-graph" class="md-nav__link">
    <span class="md-ellipsis">
      Representation of Graph
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#topological-sort" class="md-nav__link">
    <span class="md-ellipsis">
      Topological Sort
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shortest-path-algorithms" class="md-nav__link">
    <span class="md-ellipsis">
      Shortest Path Algorithms
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Shortest Path Algorithms">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#single-source-shortest-path-problem" class="md-nav__link">
    <span class="md-ellipsis">
      Single-Source Shortest-Path Problem
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Single-Source Shortest-Path Problem">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#unweighted-shortest-paths" class="md-nav__link">
    <span class="md-ellipsis">
      Unweighted Shortest Paths
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dijkstras-algorithmfor-weighted-shortest-paths" class="md-nav__link">
    <span class="md-ellipsis">
      Dijkstra's Algorithm(for weighted shortest paths)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#graphs-with-negative-edge-costs" class="md-nav__link">
    <span class="md-ellipsis">
      Graphs with Negative Edge Costs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#acyclic-graphs" class="md-nav__link">
    <span class="md-ellipsis">
      Acyclic Graphs
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#all-pairs-shortest-path-problem" class="md-nav__link">
    <span class="md-ellipsis">
      All-pairs Shortest Path Problem
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#network-flow-problems" class="md-nav__link">
    <span class="md-ellipsis">
      Network Flow Problems
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Network Flow Problems">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#simple-algorithm" class="md-nav__link">
    <span class="md-ellipsis">
      Simple Algorithm
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solution" class="md-nav__link">
    <span class="md-ellipsis">
      Solution
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#analysis" class="md-nav__link">
    <span class="md-ellipsis">
      Analysis
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#supplements" class="md-nav__link">
    <span class="md-ellipsis">
      Supplements
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#minimum-spanning-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Minimum Spanning Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Minimum Spanning Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#prims-algorithm" class="md-nav__link">
    <span class="md-ellipsis">
      Prim's Algorithm
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kruskals-algorithm" class="md-nav__link">
    <span class="md-ellipsis">
      Kruskal's Algorithm
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#applications-of-depth-first-search" class="md-nav__link">
    <span class="md-ellipsis">
      Applications of Depth-First Search
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Applications of Depth-First Search">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#undirected-graphs" class="md-nav__link">
    <span class="md-ellipsis">
      Undirected Graphs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#biconnectivity" class="md-nav__link">
    <span class="md-ellipsis">
      Biconnectivity
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#euler-circuits" class="md-nav__link">
    <span class="md-ellipsis">
      Euler Circuits
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#definitions" class="md-nav__link">
    <span class="md-ellipsis">
      Definitions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Definitions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#representation-of-graph" class="md-nav__link">
    <span class="md-ellipsis">
      Representation of Graph
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#topological-sort" class="md-nav__link">
    <span class="md-ellipsis">
      Topological Sort
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#shortest-path-algorithms" class="md-nav__link">
    <span class="md-ellipsis">
      Shortest Path Algorithms
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Shortest Path Algorithms">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#single-source-shortest-path-problem" class="md-nav__link">
    <span class="md-ellipsis">
      Single-Source Shortest-Path Problem
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Single-Source Shortest-Path Problem">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#unweighted-shortest-paths" class="md-nav__link">
    <span class="md-ellipsis">
      Unweighted Shortest Paths
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dijkstras-algorithmfor-weighted-shortest-paths" class="md-nav__link">
    <span class="md-ellipsis">
      Dijkstra's Algorithm(for weighted shortest paths)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#graphs-with-negative-edge-costs" class="md-nav__link">
    <span class="md-ellipsis">
      Graphs with Negative Edge Costs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#acyclic-graphs" class="md-nav__link">
    <span class="md-ellipsis">
      Acyclic Graphs
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#all-pairs-shortest-path-problem" class="md-nav__link">
    <span class="md-ellipsis">
      All-pairs Shortest Path Problem
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#network-flow-problems" class="md-nav__link">
    <span class="md-ellipsis">
      Network Flow Problems
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Network Flow Problems">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#simple-algorithm" class="md-nav__link">
    <span class="md-ellipsis">
      Simple Algorithm
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#solution" class="md-nav__link">
    <span class="md-ellipsis">
      Solution
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#analysis" class="md-nav__link">
    <span class="md-ellipsis">
      Analysis
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#supplements" class="md-nav__link">
    <span class="md-ellipsis">
      Supplements
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#minimum-spanning-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Minimum Spanning Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Minimum Spanning Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#prims-algorithm" class="md-nav__link">
    <span class="md-ellipsis">
      Prim's Algorithm
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kruskals-algorithm" class="md-nav__link">
    <span class="md-ellipsis">
      Kruskal's Algorithm
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#applications-of-depth-first-search" class="md-nav__link">
    <span class="md-ellipsis">
      Applications of Depth-First Search
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Applications of Depth-First Search">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#undirected-graphs" class="md-nav__link">
    <span class="md-ellipsis">
      Undirected Graphs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#biconnectivity" class="md-nav__link">
    <span class="md-ellipsis">
      Biconnectivity
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#euler-circuits" class="md-nav__link">
    <span class="md-ellipsis">
      Euler Circuits
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
    <a href="https://github.com/ZIJI-CS/T-FundamentalDataStructure/blob/main/docs/9-x.md" title="编辑此页" class="md-content__button md-icon">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25Z"/></svg>
    </a>
  
  
    
      
    
    <a href="https://github.com/ZIJI-CS/T-FundamentalDataStructure/raw/main/docs/9-x.md" title="查看本页的源代码" class="md-content__button md-icon">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0 8a5 5 0 0 1-5-5 5 5 0 0 1 5-5 5 5 0 0 1 5 5 5 5 0 0 1-5 5m0-12.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5Z"/></svg>
    </a>
  


<h1 id="chap-9-graph-algorithm">Chap 9 Graph Algorithm<a class="headerlink" href="#chap-9-graph-algorithm" title="Permanent link">&para;</a></h1>
<div style="margin-top: -30px; font-size: 0.75em; opacity: 0.7;">
<p><span class="twemoji"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2A10 10 0 0 0 2 12a10 10 0 0 0 10 10 10 10 0 0 0 10-10h-2a8 8 0 0 1-8 8 8 8 0 0 1-8-8 8 8 0 0 1 8-8V2m6.78 1a.69.69 0 0 0-.48.2l-1.22 1.21 2.5 2.5L20.8 5.7c.26-.26.26-.7 0-.95L19.25 3.2c-.13-.13-.3-.2-.47-.2m-2.41 2.12L9 12.5V15h2.5l7.37-7.38-2.5-2.5Z"/></svg></span> 约 6991 个字 <span class="twemoji"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M392.8 1.2c-17-4.9-34.7 5-39.6 22l-128 448c-4.9 17 5 34.7 22 39.6s34.7-5 39.6-22l128-448c4.9-17-5-34.7-22-39.6zm80.6 120.1c-12.5 12.5-12.5 32.8 0 45.3l89.3 89.4-89.4 89.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l112-112c12.5-12.5 12.5-32.8 0-45.3l-112-112c-12.5-12.5-32.8-12.5-45.3 0zm-306.7 0c-12.5-12.5-32.8-12.5-45.3 0l-112 112c-12.5 12.5-12.5 32.8 0 45.3l112 112c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256l89.4-89.4c12.5-12.5 12.5-32.8 0-45.3z"/></svg></span> 493 行代码 <span class="twemoji"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 20c4.42 0 8-3.58 8-8s-3.58-8-8-8-8 3.58-8 8 3.58 8 8 8m0-18c5.5 0 10 4.5 10 10s-4.5 10-10 10C6.47 22 2 17.5 2 12S6.5 2 12 2m.5 11H11V7h1.5v4.26l3.7-2.13.75 1.3L12.5 13Z"/></svg></span> 预计阅读时间 41 分钟</p>
</div>
<details class="abstract">
<summary>核心知识</summary>
<ul>
<li>图的定义、性质、表示法</li>
<li>拓扑排序（AOV网）</li>
<li>最短路问题<ul>
<li>无权</li>
<li>带正边权：Dijkstra 算法</li>
<li>有负边权</li>
<li>AOE网</li>
</ul>
</li>
<li>网络流<ul>
<li>解题：流量图、残量图</li>
</ul>
</li>
<li>最小生成树(MST)<ul>
<li>Prim算法</li>
<li>Kruskal算法</li>
</ul>
</li>
<li>深度优先搜索(DFS)<ul>
<li>基本算法</li>
<li>关节点（割点）、双连通分量</li>
<li>欧拉路、欧拉环</li>
</ul>
</li>
</ul>
</details>
<blockquote>
<p>详细的图论知识见离散数学<a href="https://note.noughtq.top/math/dm/10">同名章节</a></p>
</blockquote>
<h2 id="definitions">Definitions<a class="headerlink" href="#definitions" title="Permanent link">&para;</a></h2>
<ul>
<li><strong>G(V, E)</strong>：<span class="arithmatex">\(G\)</span> 表示<strong>图(graph)</strong>，<span class="arithmatex">\(V = V(G)\)</span> 表示关于<strong>顶点(vertices)</strong>的有限非空集合，<span class="arithmatex">\(E = E(G)\)</span> 表示关于<strong>边(edges/arcs)</strong>的有限集合</li>
<li><strong>无向图(undirected graph)</strong>：<span class="arithmatex">\((v_i, v_j) = (v_j, v_i)\)</span> 表示相同的边</li>
<li><strong>有向图(directed graph, digraph)</strong>：<span class="arithmatex">\(&lt;v_i, v_j&gt; \ne &lt;v_j, v_i&gt;\)</span></li>
</ul>
<details class="example" open="open">
<summary><span class="arithmatex">\(&lt;v_i, v_j&gt;\)</span></summary>
<p><div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240417_200539.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240417_200539.png" width="20%" style="margin: 0 auto;"></a>
</div></p>
</details>
<details class="warning" open="open">
<summary>限制</summary>
<ul>
<li>
<p><strong>自环(self loop)</strong>是非法的</p>
<p><div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240417_200725.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240417_200725.png" width="20%" style="margin: 0 auto;"></a>
</div></p>
</li>
<li>
<p>不考虑<strong>多重图(multigraph)</strong>（两个节点间有多条边）的情况</p>
<p><div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240417_200917.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240417_200917.png" width="20%" style="margin: 0 auto;"></a>
</div></p>
</li>
</ul>
</details>
<ul>
<li>
<p><strong>完全图(complete graph)</strong>：图上任意两点间都有一条边</p>
<ul>
<li>
<p>无向图：<span class="arithmatex">\(V = n \quad E = C^2_n = \frac{n(n - 1)}{2}\)</span></p>
<p><div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240417_201101.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240417_201101.png" width="20%" style="margin: 0 auto;"></a>
</div></p>
</li>
<li>
<p>有向图：<span class="arithmatex">\(V = n \quad E = P^2_n = n(n - 1)\)</span></p>
<p><div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240417_201159.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240417_201159.png" width="20%" style="margin: 0 auto;"></a>
</div></p>
</li>
</ul>
</li>
<li>
<p><strong>邻接(adjacent)</strong></p>
<ul>
<li>
<p>无向图：如果<span class="arithmatex">\((v_i, v_j)\)</span>存在，则称<span class="arithmatex">\(v_i, v_j\)</span>是<em>邻接的</em></p>
<p><div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240417_201534.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240417_201534.png" width="20%" style="margin: 0 auto;"></a>
</div></p>
</li>
<li>
<p>有向图：如果<span class="arithmatex">\(&lt;v_i, v_j&gt;\)</span>存在，则称<span class="arithmatex">\(v_i\)</span> to <span class="arithmatex">\(v_j\)</span>是<em>邻接的</em>，或者说<span class="arithmatex">\(v_j\)</span> from <span class="arithmatex">\(v_i\)</span>是<em>邻接的</em></p>
<p><div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240417_201543.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240417_201543.png" width="20%" style="margin: 0 auto;"></a>
</div></p>
</li>
</ul>
</li>
<li>
<p><strong>子图(subgraph)</strong> <span class="arithmatex">\(G' \subset G\)</span>，<span class="arithmatex">\(V(G') \subseteq V(G)\)</span> 且 <span class="arithmatex">\(E(G') \subseteq E(G)\)</span></p>
</li>
<li>从<span class="arithmatex">\(v_p\)</span>到<span class="arithmatex">\(v_q\)</span>的<strong>路径(path)</strong>(<span class="arithmatex">\(\subset G\)</span>)：<span class="arithmatex">\(\{v_p, v_{i1}, v_{i2}, \dots, v_{in}, v_q\}\)</span>，满足 <span class="arithmatex">\((v_p, v_{i1}), (v_{i1}, v_{i2}), \dots, (v_{in}, v_q)\)</span> 或者 <span class="arithmatex">\(&lt;v_p, v_{i1}&gt;, &lt;v_{i1}, v_{i2}&gt;, \dots, &lt;v_{in}, v_q&gt; \subset E(G)\)</span></li>
<li>路径的<strong>长度(length)</strong>：路径上边的条数</li>
<li><strong>简单路径(simple path)</strong>：对于上述路径，<span class="arithmatex">\(v_{i1}, v_{i2}, \dots, v_{in}\)</span> 是不同的(不会多次经过同一顶点)</li>
<li><strong>环(cycle)</strong>：对于一条简单路径，起点与终点相同，即 <span class="arithmatex">\(v_p = v_q\)</span></li>
<li>
<p><strong>连通(connected)</strong></p>
<ul>
<li>
<p>无向图：</p>
<ul>
<li>对于两个顶点 <span class="arithmatex">\(v_i, v_j\)</span> 而言，如果它们之间存在一条路径，则称它们是<em>连通的</em></li>
<li>对于整张无向图 <span class="arithmatex">\(G\)</span> 而言，如果图内任意两点之间相互连通，则称整张图是<em>连通的</em><blockquote>
<p>对于 <span class="arithmatex">\(n\)</span> 个顶点的无向图，最少需要 <span class="arithmatex">\(n - 1\)</span> 条边来实现整张图的连通</p>
</blockquote>
</li>
<li>无向图 <span class="arithmatex">\(G\)</span> 的<strong>（连通）分量(component)</strong>：极大连通子图（一张图中可能有多个连通分量）</li>
<li><strong>树</strong>是连通且无环(acyclic)的图</li>
</ul>
</li>
<li>
<p>有向图：</p>
<ul>
<li><strong>有向无环图(directed acyclic graph, DAG)</strong></li>
<li><strong>强连通(strongly connected)</strong>有向图 <span class="arithmatex">\(G\)</span>：对于 <span class="arithmatex">\(V(G)\)</span> 中的每对顶点 <span class="arithmatex">\(v_i, v_j\)</span>，存在从 <span class="arithmatex">\(v_i\)</span> 到 <span class="arithmatex">\(v_j\)</span> <strong>以及</strong>从 <span class="arithmatex">\(v_j\)</span> 到 <span class="arithmatex">\(v_i\)</span> 的有向路径</li>
<li>
<p><strong>弱连通(weakly connected)</strong>有向图：在不考虑方向的情况下（即无向图），整张图是连通的（即对于 <span class="arithmatex">\(V(G)\)</span> 中的每对顶点 <span class="arithmatex">\(v_i, v_j\)</span>，存在从 <span class="arithmatex">\(v_i\)</span> 到 <span class="arithmatex">\(v_j\)</span><strong> 或 </strong>从 <span class="arithmatex">\(v_j\)</span> 到 <span class="arithmatex">\(v_i\)</span> 的有向路径）</p>
<blockquote>
<p>对于 <span class="arithmatex">\(n\)</span> 个顶点的<em>弱连通有向图</em>，最少需要 <span class="arithmatex">\(n - 1\)</span> 条边来实现整张图的连通</p>
</blockquote>
</li>
<li>
<p><strong>强连通分量(strongly connected component)</strong>：极大强连通子图</p>
</li>
<li><strong>弱连通分量(weakly connected component)</strong>：极大弱连通子图</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>度(degree)</strong>：<span class="arithmatex">\(\mathrm{degree}(v)\)</span>，与顶点v相连的边数</p>
<p>对于一个有向图 <span class="arithmatex">\(G\)</span> 而言，度分为<strong>入度(in-degree)</strong>和<strong>出度(out-degree)</strong>，例如：</p>
<p><div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240417_203628.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240417_203628.png" width="80%" style="margin: 0 auto;"></a>
</div></p>
<p>假如 <span class="arithmatex">\(G\)</span> 有 <span class="arithmatex">\(v\)</span> 个顶点和 <span class="arithmatex">\(e\)</span> 条边，那么 <span class="arithmatex">\(e = \dfrac{\sum\limits_{i = 0}^{n - 1}d_i}{2}\)</span>，其中 <span class="arithmatex">\(d_i = \text{degree}(v_i)\)</span>（<a href="https://note.noughtq.top/math/dm/10#basic-terminology">握手定理</a>）</p>
<p>对于有向图而言，所有顶点入度之和 = 所有顶点出度之和</p>
</li>
</ul>
<h3 id="representation-of-graph">Representation of Graph<a class="headerlink" href="#representation-of-graph" title="Permanent link">&para;</a></h3>
<p>法一：<strong>邻接矩阵(adjacency matrix)</strong></p>
<p>对于一张具有 <span class="arithmatex">\(n(n \ge 1)\)</span> 个节点的图 <span class="arithmatex">\(G(V, E)\)</span>，定义邻接矩阵 <span class="arithmatex">\(adj\_mat [i] [j]\)</span>为</p>
<div class="arithmatex">\[
adj\_mat[i][j] = \begin{cases}1 &amp; \text{if } (v_i, v_j) \text{ or } &lt;v_i, v_j&gt; \in E(G) \\ 0 &amp; \text{otherwise}\end{cases}
\]</div>
<p>所以也就有：</p>
<div class="arithmatex">\[
\text{degree}(i) = \begin{cases}\sum\limits_{j = 0}^{n - 1} adj\_mat[i][j] &amp; \text{if G is undirected} \\ \sum\limits_{j = 0}^{n - 1} adj\_mat[i][j] + \sum\limits_{j = 0}^{n - 1}adj\_mat[j][i] &amp; \text{if G is directed} \end{cases}
\]</div>
<p>不难看出，如果<span class="arithmatex">\(G\)</span>是无向的，则该邻接矩阵是对称的，因此浪费了一半的空间和时间（复杂度：<span class="arithmatex">\(\Theta(|V|^2)\)</span>），但是用在<strong>稠密(dense)图</strong>（<span class="arithmatex">\(|E| = \Theta(|V|^2)\)</span>）中是比较合适的。</p>
<p>改进措施：通过将<strong>下三角矩阵</strong>存入一维数组中，节省了一半的空间</p>
<p><span class="arithmatex">\(adj\_mat[n(n+1)/2] = \{a_{11}, a_{21}, \dots, a_{n1}, \dots, a_{nn}\}\)</span>，其中 <span class="arithmatex">\(a_{ij}\)</span> 的索引为 <span class="arithmatex">\(\dfrac{i(i-1)}{2} + j\)</span></p>
<hr />
<p>法二：<strong>邻接表(adjacency lists)</strong></p>
<details class="example" open="open">
<summary>例子</summary>
<p>如何存储这张图？</p>
<p><div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240417_205817.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240417_205817.png" width="40%" style="margin: 0 auto;"></a>
</div></p>
<div class="tabbed-set tabbed-alternate" data-tabs="1:2"><input checked="checked" id="__tabbed_1_1" name="__tabbed_1" type="radio" /><input id="__tabbed_1_2" name="__tabbed_1" type="radio" /><div class="tabbed-labels"><label for="__tabbed_1_1">邻接矩阵</label><label for="__tabbed_1_2">邻接表</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<div class="arithmatex">\[adj\_mat = \begin{bmatrix}0 &amp; 1 &amp; 0 \\ 1 &amp; 0 &amp; 1 \\ 0 &amp; 0 &amp; 0\end{bmatrix}\]</div>
</div>
<div class="tabbed-block">
<p><div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240417_210032.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240417_210032.png" width="40%" style="margin: 0 auto;"></a>
</div></p>
<blockquote>
<p>注：节点的顺序并不重要</p>
</blockquote>
</div>
</div>
</div>
</details>
<p>对于无向图 <span class="arithmatex">\(G\)</span>，邻接表的空间 <span class="arithmatex">\(S = n\)</span> 个头 + <span class="arithmatex">\(2e\)</span>个节点 = <span class="arithmatex">\((n + 2e)\)</span>个指针 + <span class="arithmatex">\(2e\)</span>个整型</p>
<p>时间复杂度 <span class="arithmatex">\(T = E(G) = O(|V| + |E|)\)</span>，适用于<strong>稀疏(sparse)图</strong>(<span class="arithmatex">\(|E| &lt; \Theta(|V|^2)\)</span>)中</p>
<blockquote>
<p>注：事实上，邻接表可以胜任各种图的存储</p>
</blockquote>
<div class="admonition note">
<p class="admonition-title">如何计算某个顶点的度</p>
<div class="tabbed-set tabbed-alternate" data-tabs="2:2"><input checked="checked" id="__tabbed_2_1" name="__tabbed_2" type="radio" /><input id="__tabbed_2_2" name="__tabbed_2" type="radio" /><div class="tabbed-labels"><label for="__tabbed_2_1">无向图</label><label for="__tabbed_2_2">有向图</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>Degree(i) = graph[i]中节点的个数</p>
</div>
<div class="tabbed-block">
<p>我们需要找到in-degree(i)</p>
<ul>
<li>
<p>法 1：“逆转”邻接链表</p>
<p><div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240417_210654.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240417_210654.png" width="40%" style="margin: 0 auto;"></a>
</div></p>
</li>
<li>
<p>法 2：用<a href="3-x.html#multilists"><strong>多链表(multilist)</strong></a>表示邻接矩阵<span class="arithmatex">\(adj\_mat[i][j]\)</span></p>
<p><div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240417_210838.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240417_210838.png" width="40%" style="margin: 0 auto;"></a>
</div></p>
</li>
</ul>
<p>众所周知，多链表实现相当复杂，因此更推荐法 1</p>
</div>
</div>
</div>
<details class="info" open="open">
<summary>补充</summary>
<p>有时顶点的值不一定是整数，也有可能是字符串，这时需要维护一张从字符串映射到整数索引的表格，在图中用索引代替字符串</p>
</details>
</div>
<hr />
<p>法三：邻接多重表(adjacency multilist)</p>
<blockquote>
<p>注：这个不作要求，了解即可</p>
</blockquote>
<p>在之前的邻接表里，对于每条边 <span class="arithmatex">\((v_i, v_j)\)</span>，我们会有两个节点：</p>
<div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240417_211329.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240417_211329.png" width="40%" style="margin: 0 auto;"></a>
</div>

<p>通过改进，将这两个节点结合到一起：</p>
<div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240417_211529.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240417_211529.png" width="40%" style="margin: 0 auto;"></a>
</div>

<p>于是就有如下表示方法（mark 表示某一条边）：</p>
<div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240417_211427.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240417_211427.png" width="20%" style="margin: 0 auto;"></a>
</div>

<p>最终效果：</p>
<div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240417_211622.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240417_211622.png" width="50%" style="margin: 0 auto;"></a>
</div>

<p>观察发现，在没有考虑 mark 存储的情况下，这种表示法的占用空间与邻接表完全一样。虽然它的空间复杂度略微高了点，但是在某些情况下（比如检验某条边后还要检验下一条边）比较有利。</p>
<hr />
<p>有时，我们会遇到<strong>带权边(weighted edges)</strong>的情况，处理方式如下：</p>
<ul>
<li>邻接矩阵：<span class="arithmatex">\(adj\_mat[i][j] = \text{weight}\)</span></li>
<li>邻接表/邻接多重表：为每个节点添加权重的字段</li>
</ul>
<h2 id="topological-sort">Topological Sort<a class="headerlink" href="#topological-sort" title="Permanent link">&para;</a></h2>
<p><strong>AOV网(activity on vertex network)</strong>：对于有向图 <span class="arithmatex">\(G\)</span>，<span class="arithmatex">\(V(G)\)</span> 表示活动，<span class="arithmatex">\(E(G)\)</span> 表示位次关系</p>
<p><img alt="🌰" class="twemoji" src="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.0.3/assets/svg/1f330.svg" title=":chestnut:" />（C1 是 C3 的前置活动）</p>
<div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240417_212653.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240417_212653.png" width="20%" style="margin: 0 auto;"></a>
</div>

<ul>
<li>如果从 <span class="arithmatex">\(i\)</span> 到 <span class="arithmatex">\(j\)</span> 有一条路径，则称 <span class="arithmatex">\(i\)</span> 是 <span class="arithmatex">\(j\)</span> 的<strong>前任(predecessor)</strong></li>
<li>如果 <span class="arithmatex">\(&lt;i, j&gt; \in E(G)\)</span>，则称 <span class="arithmatex">\(i\)</span> 是 <span class="arithmatex">\(j\)</span> 的<strong>直接前任(immediate predecessor)</strong>。称 <span class="arithmatex">\(j\)</span> 是 <span class="arithmatex">\(i\)</span> 的 <strong>（直接）后任((immediate) successor)</strong></li>
</ul>
<p>可行的AOV网必须是一个<strong>有向无环图(DAG)</strong></p>
<blockquote>
<p>补充阅读：<a href="https://oi-wiki.org/graph/topo/">AOE网</a></p>
</blockquote>
<p><strong>偏序(partial order)</strong>是一种具有以下性质的关系</p>
<ul>
<li><strong>反自反性(irreflexive)</strong>（不存在 <span class="arithmatex">\(i \rightarrow i\)</span>）</li>
<li><strong>反对称性(anti-symmetric)</strong>（<span class="arithmatex">\((i \rightarrow j) \wedge (j \rightarrow i) \Rightarrow i = j\)</span>）</li>
<li><strong>传递性</strong>（<span class="arithmatex">\(i \rightarrow j, j \rightarrow k \Rightarrow i \rightarrow k\)</span>）</li>
</ul>
<div class="admonition info">
<p class="admonition-title">说明</p>
<ul>
<li>这里的偏序指的是<strong>严格偏序</strong>，因此和离散数学定义的<a href="https://note.noughtq.top/math/dm/9#partial-orderings">偏序</a>略有区别</li>
<li>如果具有自反性，就会出现要做一件事 <span class="arithmatex">\(i\)</span> 之前要完成 <span class="arithmatex">\(i\)</span> 的怪圈，因此❌</li>
</ul>
</div>
<hr />
<p><strong>拓扑序(topological order)</strong>是一张图的顶点的线性顺序，满足：对于任意两个顶点 <span class="arithmatex">\(i, j\)</span>，如果 <span class="arithmatex">\(i\)</span> 是 <span class="arithmatex">\(j\)</span> 的前任，则在线性顺序中 <span class="arithmatex">\(i\)</span> 要出现在 <span class="arithmatex">\(j\)</span> 之前</p>
<p>注：</p>
<ul>
<li>拓扑序不一定是唯一的</li>
<li>如果拓扑序中一个顶点出现在另一个顶点的前面，它们之间不一定存在路径</li>
<li>可以用拓扑序检验有向图是否存在环</li>
</ul>
<details class="code">
<summary>代码实现</summary>
<div class="highlight"><pre><span></span><code><span class="c1">// version 1</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Topsort</span><span class="p">(</span><span class="n">Graph</span><span class="w"> </span><span class="n">G</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">Counter</span><span class="p">;</span>
<span class="w">    </span><span class="n">Vertex</span><span class="w"> </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">W</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">Counter</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NumVertex</span><span class="p">;</span><span class="w"> </span><span class="n">Counter</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">V</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FindNewVertexOfDegreeZero</span><span class="p">();</span><span class="w"> </span><span class="c1">// O(|V|)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">V</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">NotAVertex</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">Error</span><span class="p">(</span><span class="s">&quot;Graph has a cycle&quot;</span><span class="p">);</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">TopNum</span><span class="p">[</span><span class="n">V</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Counter</span><span class="p">;</span><span class="w"> </span><span class="c1">// or output V</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">each</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="n">adjacent</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>
<span class="w">            </span><span class="n">indegreep</span><span class="p">[</span><span class="n">W</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
</details>
<ul>
<li><code>FindNewVertexOfDegreeZero()</code>：扫描 <code>Indegree[]</code> 数组，找到入度为 0 且未赋予拓扑序的顶点，如果没有找到顶点，那么表明图中出现了环</li>
<li>每处理完一个顶点 V 后，就需要让从 V 出发与 V 邻接的顶点的入度 -1，相当于在图上移除了顶点 V 以及它的所有出边</li>
<li>时间复杂度：<span class="arithmatex">\(T = O(|V|^2)\)</span> 👎</li>
</ul>
<hr />
<p>改进方法：将所有<strong>未赋予拓扑序的、度为 0 的顶点</strong>放入特殊的盒子（比如<strong>队列</strong>或*<em>栈</em>）里</p>
<details class="play">
<summary>动画演示</summary>
<p><div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/11.gif" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/11.gif" width="30%" style="margin: 0 auto;"></a>
</div></p>
</details>
<details class="code">
<summary>代码实现</summary>
<div class="highlight"><pre><span></span><code><span class="c1">// version 2, using queue ADT</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Topsort</span><span class="p">(</span><span class="n">Graph</span><span class="w"> </span><span class="n">G</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Queue</span><span class="w"> </span><span class="n">Q</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">Counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">Vertex</span><span class="w"> </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">W</span><span class="p">;</span>

<span class="w">    </span><span class="n">Q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateQueue</span><span class="p">(</span><span class="n">NumVertex</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">each</span><span class="w"> </span><span class="n">vertex</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">indegree</span><span class="p">[</span><span class="n">V</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="n">Enqueue</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">Q</span><span class="p">);</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">(</span><span class="n">Q</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">V</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Dequeue</span><span class="p">(</span><span class="n">Q</span><span class="p">);</span>
<span class="w">        </span><span class="n">TopNum</span><span class="p">[</span><span class="n">V</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">++</span><span class="n">Counter</span><span class="p">;</span><span class="w">  </span><span class="c1">// assign next</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">each</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="n">adjacent</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">--</span><span class="n">indegree</span><span class="p">[</span><span class="n">W</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">                </span><span class="n">Enqueue</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="w"> </span><span class="n">Q</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// end-while</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Counter</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">NumVertex</span><span class="p">)</span>
<span class="w">        </span><span class="n">Error</span><span class="p">(</span><span class="s">&quot;Graph has a cycle&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="n">DisposeQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">);</span><span class="w"> </span><span class="c1">// free memery</span>
<span class="p">}</span>
</code></pre></div>
</details>
<p>时间复杂度：<span class="arithmatex">\(O(|E| + |V|)\)</span></p>
<details class="example">
<summary>例题</summary>
<div class="tabbed-set tabbed-alternate" data-tabs="3:2"><input checked="checked" id="__tabbed_3_1" name="__tabbed_3" type="radio" /><input id="__tabbed_3_2" name="__tabbed_3" type="radio" /><div class="tabbed-labels"><label for="__tabbed_3_1">问题</label><label for="__tabbed_3_2">答案</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p><div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240417_214857.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240417_214857.png" width="80%" style="margin: 0 auto;"></a>
</div></p>
</div>
<div class="tabbed-block">
<p><div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240417_214925.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240417_214925.png" width="80%" style="margin: 0 auto;"></a>
</div></p>
</div>
</div>
</div>
</details>
<h2 id="shortest-path-algorithms">Shortest Path Algorithms<a class="headerlink" href="#shortest-path-algorithms" title="Permanent link">&para;</a></h2>
<p>给定一张有向图 <span class="arithmatex">\(G(V, E)\)</span>，以及成本函数 <span class="arithmatex">\(c(e)\)</span>，<span class="arithmatex">\(e \in E(G)\)</span>，从<strong>源(source)</strong>到<strong>目的地(destination)</strong>的路径 <span class="arithmatex">\(P\)</span> 的长度(length)为 <span class="arithmatex">\(\sum\limits_{e_i \subset P}c(e_i)\)</span>（也称为<strong>带权路径长度(weighted path length)</strong>）</p>
<h3 id="single-source-shortest-path-problem">Single-Source Shortest-Path Problem<a class="headerlink" href="#single-source-shortest-path-problem" title="Permanent link">&para;</a></h3>
<div class="admonition question">
<p class="admonition-title">问题</p>
<p>给定一张权重图 <span class="arithmatex">\(G(V, E)\)</span>，以及一个可区分的顶点 <span class="arithmatex">\(s\)</span>，寻找从 <span class="arithmatex">\(s\)</span> 到 <span class="arithmatex">\(G\)</span> 中所有其他顶点的最短权重路径</p>
</div>
<p><img alt="🌰" class="twemoji" src="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.0.3/assets/svg/1f330.svg" title=":chestnut:" />：</p>
<div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240424_131818.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240424_131818.png" width="70%" style="margin: 0 auto;"></a>
</div>

<ul>
<li>右图存在负的边，这样最短路的长度可以是无穷小。因此在这种情况下，最短路是未定义的，因为陷入了死循环。这种循环被称为<strong>负值环(negative-cost cycle)</strong></li>
<li>从 <span class="arithmatex">\(s\)</span> 到 <span class="arithmatex">\(s\)</span> 的最短路径被定义为 0</li>
<li>现在，还没有一种最短路算法的速度快于找到从 <span class="arithmatex">\(s\)</span> 到所有顶点的路径的算法</li>
</ul>
<h4 id="unweighted-shortest-paths">Unweighted Shortest Paths<a class="headerlink" href="#unweighted-shortest-paths" title="Permanent link">&para;</a></h4>
<p>在这种情况下，所有边的权重 = 1</p>
<div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240424_132143.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240424_132143.png" width="60%" style="margin: 0 auto;"></a>
</div>

<p>如图所示，为了找到从 <span class="arithmatex">\(v_3\)</span> 出发到其他顶点的所有最短路径：</p>
<ul>
<li>先找到与 <span class="arithmatex">\(v_3\)</span> 邻接的顶点，记从 <span class="arithmatex">\(v_3\)</span> 到这些顶点的最短路径为 1</li>
<li>然后再从这些顶点出发，找到与它们邻接的顶点。如果新找到的顶点还没有相应的最短路径，那就记这些顶点的最短路径为 2</li>
<li>重复步骤 2，直至所有顶点的最短路径都已找到</li>
</ul>
<p>这种方法被称为<strong>宽度优先搜索(breadth-first search, BFS)</strong>：该方法一层层地处理顶点：最近的顶点最先处理，最远的顶点最后处理。这和树中的<a href="4-x.html#tree-traversals">层序遍历</a>类似</p>
<div class="admonition note">
<p class="admonition-title">实现</p>
<ul>
<li>
<p><code>Table[i].Dist</code> ::= 从<span class="arithmatex">\(s\)</span>到<span class="arithmatex">\(v_i\)</span>的距离 <span class="arithmatex">\(= \begin{cases}\infty &amp; \text{if } v_i \ne s \\ 0 &amp; \text{if } v_i = s\end{cases}\)</span></p>
</li>
<li>
<p><code>Table[i].Known</code> ::= <span class="arithmatex">\(\begin{cases}1 \quad \text{if } v_i \text{ is checked} \\ 0 \quad \text{if not}\end{cases}\)</span></p>
</li>
</ul>
<blockquote>
<ul>
<li>其实没有必要设这个字段(因为 <code>Table[i].Dist</code> 同时具备<strong>标记</strong>功能)，写在这里只是提醒一下要做一下标记</li>
<li>在初始化中，所有顶点的 <code>Table[i].Known = 0</code>，包括起始顶点，因为没有任何顶点被处理过</li>
</ul>
</blockquote>
<ul>
<li><code>Table[i].Path</code> ::= 记录路径上 <span class="arithmatex">\(v_i\)</span> 的前一个顶点，以便打印整条路径</li>
</ul>
</div>
<details class="code">
<summary>代码实现</summary>
<div class="highlight"><pre><span></span><code><span class="c1">// version 1</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Unweighted</span><span class="p">(</span><span class="n">Table</span><span class="w"> </span><span class="n">T</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">CurrDist</span><span class="p">;</span>
<span class="w">    </span><span class="n">Vertex</span><span class="w"> </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">W</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">CurrDist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">CurrDist</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NumVertex</span><span class="p">;</span><span class="w"> </span><span class="n">CurrDist</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">each</span><span class="w"> </span><span class="n">vertex</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">T</span><span class="p">[</span><span class="n">V</span><span class="p">].</span><span class="n">Known</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">T</span><span class="p">[</span><span class="n">V</span><span class="p">].</span><span class="n">Dist</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">CurrDist</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">T</span><span class="p">[</span><span class="n">V</span><span class="p">].</span><span class="n">Known</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">each</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="n">adjacent</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">W</span><span class="p">].</span><span class="n">Dist</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">infinity</span><span class="p">)</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="n">T</span><span class="p">[</span><span class="n">W</span><span class="p">].</span><span class="n">Dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CurrDist</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">                        </span><span class="n">T</span><span class="p">[</span><span class="n">W</span><span class="p">].</span><span class="n">Path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">V</span><span class="p">;</span><span class="w">  </span><span class="c1">// (*)</span>
<span class="w">                    </span><span class="p">}</span><span class="c1">// end-if Dist == Infinity</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="c1">// end-if !Known &amp;&amp;Dist == CurrDist</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// end-for CurrDist</span>
<span class="p">}</span>
</code></pre></div>
</details>
<p>这个算法显然没什么效率，因为外层循环要循环 <code>NumVertex - 1</code> 次才结束，即使所有的顶点早就处理过了。虽然可以增加一个额外的判断提前结束循环，但这并没有影响最坏情况的运行时间，比如：</p>
<div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240424_134237.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240424_134237.png" width="70%" style="margin: 0 auto;"></a>
</div>

<p>起始点为 <span class="arithmatex">\(v_9\)</span>，第一次循环要找 <code>CurrDist == 0</code> 的顶点（即 <span class="arithmatex">\(v_9\)</span>）。我们一般会按照节点下标的递增顺序查找，则要找到 <span class="arithmatex">\(v_9\)</span> 需要从头遍历到尾；而且不难看出，每次循环均会从头遍历到尾（越来越靠前）</p>
<p>时间复杂度 <span class="arithmatex">\(T = O(|V|^2)\)</span>👎</p>
<hr />
<p>可以发现，如果顶点 <span class="arithmatex">\(V\)</span> 未被标记，但 <span class="arithmatex">\(d_v \ne \infty\)</span>，那么 <span class="arithmatex">\(d_v = CurrDist\)</span> 或 <span class="arithmatex">\(d_v = CurrDist + 1\)</span>，因此没有必要像上面那个算法一样扫描整个表来找到合适的顶点。</p>
<details class="info">
<summary>改进思路</summary>
<p>用两个箱子，一个箱子放未标记的 <span class="arithmatex">\(d_v = CurrDist\)</span> 的顶点，另一个箱子放未标记的且 <span class="arithmatex">\(d_v = CurrDist + 1\)</span> 的顶点。那么，原来扫描整张表的操作可以变成：从第 1 个箱子找任一顶点 <span class="arithmatex">\(V\)</span>，等到 (*) 那行代码执行完后，将 <span class="arithmatex">\(W\)</span> 放入第 2 个箱子。等到外层 <code>for</code> 循环一轮结束后，第 1 个箱子为空，将第 2 个箱子的顶点转移到第 1 个箱子，进行下一轮循环。</p>
</details>
<p>事实上，我们只需要一个<strong>队列</strong>就能完成上述改进思路：</p>
<blockquote>
<p>这里不用 <code>Known</code> 字段是因为 <code>Dequeue</code> 就代表顶点已经被处理过了，不会再回到队列里</p>
</blockquote>
<details class="code">
<summary>代码实现</summary>
<div class="highlight"><pre><span></span><code><span class="c1">// version 2</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Unweighted</span><span class="p">(</span><span class="n">Table</span><span class="w"> </span><span class="n">T</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// T is initialized with the source vertex S given</span>
<span class="w">    </span><span class="n">Queue</span><span class="w"> </span><span class="n">Q</span><span class="p">;</span>
<span class="w">    </span><span class="n">Vertex</span><span class="w"> </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">W</span><span class="p">;</span>
<span class="w">    </span><span class="n">Q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateQueue</span><span class="p">(</span><span class="n">NumVertex</span><span class="p">);</span>
<span class="w">    </span><span class="n">MakeEmpty</span><span class="p">(</span><span class="n">Q</span><span class="p">);</span>
<span class="w">    </span><span class="n">Enqueue</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="w"> </span><span class="n">Q</span><span class="p">);</span><span class="w"> </span><span class="c1">// Enqueue the source vertex</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">IsEmpty</span><span class="p">(</span><span class="n">Q</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">V</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Dequeue</span><span class="p">(</span><span class="n">Q</span><span class="p">);</span>
<span class="w">        </span><span class="n">T</span><span class="p">[</span><span class="n">V</span><span class="p">].</span><span class="n">Known</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w">  </span><span class="c1">// not really necessary</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">each</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="n">adjacent</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">W</span><span class="p">].</span><span class="n">Dist</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Infinity</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">T</span><span class="p">[</span><span class="n">W</span><span class="p">].</span><span class="n">Dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">[</span><span class="n">V</span><span class="p">].</span><span class="n">Dist</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">                </span><span class="n">T</span><span class="p">[</span><span class="n">W</span><span class="p">].</span><span class="n">Path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">V</span><span class="p">;</span>
<span class="w">                </span><span class="n">Enqueue</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="w"> </span><span class="n">Q</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="c1">// end-if Dist == Infinity</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// end-while</span>
<span class="w">    </span><span class="n">DisposeQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">);</span><span class="w"> </span><span class="c1">// free memory</span>
<span class="p">}</span>
</code></pre></div>
</details>
<blockquote>
<p>可以看到，这和拓扑排序的算法很像</p>
</blockquote>
<details class="play" open="open">
<summary>动画演示</summary>
<p><div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/6.gif" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/6.gif" width="30%" style="margin: 0 auto;"></a>
</div></p>
</details>
<h4 id="dijkstras-algorithmfor-weighted-shortest-paths">Dijkstra's Algorithm(for weighted shortest paths)<a class="headerlink" href="#dijkstras-algorithmfor-weighted-shortest-paths" title="Permanent link">&para;</a></h4>
<div class="admonition note">
<p class="admonition-title">Dijkstra算法的思路</p>
<p>令 <span class="arithmatex">\(S =\)</span> {<span class="arithmatex">\(s\)</span> 和已找到最短路径的顶点 <span class="arithmatex">\(v_i\)</span> 的集合}。对于 <span class="arithmatex">\(\forall u \notin S\)</span>，定义<code>distance[u]</code> = 路径 <span class="arithmatex">\(\{s \rightarrow (v_i \in S) \rightarrow u\}\)</span> 的最小长度</p>
<ul>
<li>Dijkstra 算法按阶段执行，在每个阶段中，挑选一个顶点<span class="arithmatex">\(v\)</span>，保证它是所有<strong>未被标记</strong>的顶点中路径长度<span class="arithmatex">\(d_v\)</span><strong>最短</strong>的那个顶点（如果有多个最短路径长度，则任意挑选顶点）</li>
<li>对于从顶点 <span class="arithmatex">\(v\)</span> 出发的邻接顶点 <span class="arithmatex">\(w\)</span>，<span class="arithmatex">\(d_w = \min(d_w, d_v + c_{v, w})\)</span></li>
<li>标记顶点 <span class="arithmatex">\(v\)</span>，即令 <span class="arithmatex">\(v \in S\)</span></li>
<li>然后对于剩余未被标记的顶点，重复上述操作，直至所有顶点均被标记</li>
</ul>
<p>不难发现，这是一种<strong>贪心算法</strong></p>
</div>
<details class="code">
<summary>预备工作</summary>
<div class="highlight"><pre><span></span><code><span class="c1">// Declarations for Dijkstra&#39;s algorithm</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Vertex</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">TableEntry</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">List</span><span class="w"> </span><span class="n">Header</span><span class="p">;</span><span class="w"> </span><span class="c1">// Adjacency list</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">Known</span><span class="p">;</span>
<span class="w">    </span><span class="n">DistType</span><span class="w"> </span><span class="n">Dist</span><span class="p">;</span>
<span class="w">    </span><span class="n">Vertex</span><span class="w"> </span><span class="n">Path</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Vertices are numbered from 0</span>
<span class="cp">#define NotAVerTex (-1)</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">TableEntry</span><span class="w"> </span><span class="n">Table</span><span class="p">[</span><span class="n">NumVertex</span><span class="p">];</span>

<span class="c1">// Initialization</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">InitTable</span><span class="p">(</span><span class="n">Vertex</span><span class="w"> </span><span class="n">Start</span><span class="p">,</span><span class="w"> </span><span class="n">Graph</span><span class="w"> </span><span class="n">G</span><span class="p">,</span><span class="w"> </span><span class="n">Table</span><span class="w"> </span><span class="n">T</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>

<span class="w">    </span><span class="n">ReadGraph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NumVertex</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Known</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">False</span><span class="p">;</span>
<span class="w">        </span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Infinity</span><span class="p">;</span>
<span class="w">        </span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NotAVerTex</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">T</span><span class="p">[</span><span class="n">Start</span><span class="p">].</span><span class="n">dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Print shortest path to V after Dijkstra has run</span>
<span class="c1">// Assume that the path exists</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">PrintPath</span><span class="p">(</span><span class="n">Vertex</span><span class="w"> </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">Table</span><span class="w"> </span><span class="n">T</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">V</span><span class="p">].</span><span class="n">Path</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">NotAVertex</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">PrintPath</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">V</span><span class="p">].</span><span class="n">Path</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="p">);</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot; to&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%v&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">)</span><span class="w"> </span><span class="c1">// %v is pseudocode</span>
<span class="p">}</span>
</code></pre></div>
</details>
<details class="code">
<summary>代码实现</summary>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">Dijkstra</span><span class="p">(</span><span class="n">Table</span><span class="w"> </span><span class="n">T</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Vertex</span><span class="w"> </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">W</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="p">(;;)</span><span class="w">  </span><span class="c1">// O(|V|)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">V</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">smallest</span><span class="w"> </span><span class="n">unknown</span><span class="w"> </span><span class="n">distance</span><span class="w"> </span><span class="n">vertex</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">V</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">NotAVertex</span><span class="p">)</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="n">T</span><span class="p">[</span><span class="n">V</span><span class="p">].</span><span class="n">Known</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">each</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="n">adjacent</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">T</span><span class="p">[</span><span class="n">W</span><span class="p">].</span><span class="n">Known</span><span class="p">)</span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">V</span><span class="p">].</span><span class="n">Dist</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Cvw</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">T</span><span class="p">[</span><span class="n">W</span><span class="p">].</span><span class="n">Dist</span><span class="p">)</span><span class="w"> </span><span class="c1">// 这步操作称为“松弛”</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">Decrease</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">W</span><span class="p">].</span><span class="n">Dist</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">T</span><span class="p">[</span><span class="n">V</span><span class="p">].</span><span class="n">Dist</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Cvw</span><span class="p">);</span>
<span class="w">                    </span><span class="n">T</span><span class="p">[</span><span class="n">W</span><span class="p">].</span><span class="n">Path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">V</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="c1">// end-if update W</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// end-for(;;)</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// now work for edge with negative cost</span>
</code></pre></div>
</details>
<details class="play" open="open">
<summary>动画演示</summary>
<p><div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/7.gif" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/7.gif" width="30%" style="margin: 0 auto;"></a>
</div></p>
</details>
<p>Dijkstra 算法的运行时间取决于我们<u>如何寻找距离最短且未被标记的顶点</u></p>
<div class="admonition note">
<p class="admonition-title">方法</p>
<div class="tabbed-set tabbed-alternate" data-tabs="4:2"><input checked="checked" id="__tabbed_4_1" name="__tabbed_4" type="radio" /><input id="__tabbed_4_2" name="__tabbed_4" type="radio" /><div class="tabbed-labels"><label for="__tabbed_4_1">方法1</label><label for="__tabbed_4_2">方法2</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<ul>
<li>仅仅简单扫描一遍整张表来找到 <span class="arithmatex">\(d_v\)</span> 最小的顶点 <span class="arithmatex">\(v \rightarrow O(|V|)\)</span>；而且外层循环遍历所有顶点，因此时间复杂度为 <span class="arithmatex">\(O(|V|^2)\)</span></li>
<li>每条边最多会更新一次，时间复杂度为 <span class="arithmatex">\(O(|E|)\)</span>，而且与顶点的遍历是<em>独立</em>的</li>
<li>因此 <span class="arithmatex">\(T = O(|V|^2 + |E|)\)</span>，适用于<em>稠密图</em>（此时复杂度相当于线性复杂度）</li>
</ul>
</div>
<div class="tabbed-block">
<p>将距离保存在<strong>堆</strong>里，调用 <code>DeleteMin</code> 来找到未标记的最小顶点，并且之后不去管它。</p>
<p>那么如何实现算法中的 <code>Decrease(T[W].Dist to T[V].Dist + Cvw);</code> 呢？</p>
<div class="tabbed-set tabbed-alternate" data-tabs="5:2"><input checked="checked" id="__tabbed_5_1" name="__tabbed_5" type="radio" /><input id="__tabbed_5_2" name="__tabbed_5" type="radio" /><div class="tabbed-labels"><label for="__tabbed_5_1">法1</label><label for="__tabbed_5_2">法2</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p><code>DecreaseKey()</code> <span class="arithmatex">\(\rightarrow O(\log |V|)\)</span>，因此<span class="arithmatex">\(T = O(|V|\log |V| + |E| \log |V|) = O(|E|\log |V|)\)</span>，适用于<em>稀疏图</em></p>
<p>但是，因为堆不能有效支持 <code>Find</code> 操作，当 <span class="arithmatex">\(d_i\)</span> 的值发生改变时，它的位置需要维护和更新，用二叉堆实现起来有些麻烦。</p>
<blockquote>
<p>如果用到<a href="https://oi-wiki.org/ds/pairing-heap/"><strong>配对堆(pairing heap)</strong></a>，情况就会改善，这种改进不做要求</p>
</blockquote>
</div>
<div class="tabbed-block">
<p>将更新后的 <span class="arithmatex">\(d_w\)</span> 插入堆中，这样的话堆内就会出现多个表示同一顶点的距离。因此在 <code>V = smallest unknown distance vertex;</code> 这一句中，要重复使用 <code>DeleteMin</code>，直到未标记的点出现（标记过的点就扔掉不用）。虽然这种方法会扩大堆的规模（<span class="arithmatex">\(O(|E|)\)</span>），但是因为 <span class="arithmatex">\(|E| \le |V|^2\)</span>。所以 <span class="arithmatex">\(\log |E| \le 2\log |V|\)</span>，因此 <span class="arithmatex">\(T = O(|E| \log |V|)\)</span>。但它占用空间大于法 1 需要 <span class="arithmatex">\(|E|\)</span> 次 <code>DeleteMin</code> 操作，因此在实际运行中可能会变慢。</p>
<blockquote>
<p>其他改进方法：<a href="https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86">斐波那契堆(Fibonacci heap)</a></p>
</blockquote>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<details class="code">
<summary>具体实现</summary>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">Dijkstra</span><span class="p">(</span><span class="n">VType</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">Table</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w">   </span><span class="c1">// Finding all the shortest paths</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">VType</span><span class="w"> </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">W</span><span class="p">;</span><span class="w">           </span><span class="c1">// V: the current vertex; W: the vertex adjacent to V</span>
<span class="w">    </span><span class="n">Heap</span><span class="w"> </span><span class="n">H</span><span class="p">;</span><span class="w">               </span><span class="c1">// A heap maintaining the shortest unknown vertex</span>
<span class="w">    </span><span class="n">Vertex</span><span class="w"> </span><span class="n">cur</span><span class="p">,</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span><span class="w">      </span><span class="c1">// cur: obtaining the information of all adjacent vertice regarding V; tmp: containing new previous vertex adjacent to W</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="n">cnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w">     </span><span class="c1">// len: the distance of T[V].dist + the distance between V and W; cnt: used to terminate the loop</span>

<span class="w">    </span><span class="n">H</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">InitHeap</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">);</span><span class="w">   </span><span class="c1">// Initialization of the heap</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">cnt</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">V</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DeleteMin</span><span class="p">(</span><span class="n">H</span><span class="p">);</span><span class="w"> </span><span class="c1">// Obtaining the shortest unknown vertex</span>
<span class="w">        </span><span class="n">T</span><span class="p">[</span><span class="n">V</span><span class="p">].</span><span class="n">Known</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">   </span><span class="c1">// Marking it</span>
<span class="w">        </span><span class="n">cnt</span><span class="o">--</span><span class="p">;</span>
<span class="w">        </span><span class="n">cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">G</span><span class="p">[</span><span class="n">V</span><span class="p">];</span><span class="w">       </span><span class="c1">// Getting all adjacent successors</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">cur</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w">  </span><span class="c1">// Traversing all successors</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">;</span><span class="w">  </span><span class="c1">// The current successor</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">T</span><span class="p">[</span><span class="n">W</span><span class="p">].</span><span class="n">Known</span><span class="p">)</span><span class="w">  </span><span class="c1">// If W isn&#39;t marked, then try to update it</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">[</span><span class="n">V</span><span class="p">].</span><span class="n">Dist</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="w">   </span><span class="c1">// New distance</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">T</span><span class="p">[</span><span class="n">W</span><span class="p">].</span><span class="n">Dist</span><span class="p">)</span><span class="w">  </span><span class="c1">// If the new distance is shorter than the previous one, then update it</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">T</span><span class="p">[</span><span class="n">W</span><span class="p">].</span><span class="n">Dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">len</span><span class="p">;</span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="n">W</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">  </span><span class="c1">// If W hasn&#39;t been in the heap, then insert it into the heap</span>
<span class="w">                        </span><span class="n">Insert</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="n">H</span><span class="p">);</span>
<span class="w">                    </span><span class="k">else</span><span class="w">  </span><span class="c1">// If W is in the heap, then update the distance of W and update the whole heap</span>
<span class="w">                        </span><span class="n">DecreaseKey</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="n">W</span><span class="p">],</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="n">H</span><span class="p">);</span>

<span class="w">                    </span><span class="n">T</span><span class="p">[</span><span class="n">W</span><span class="p">].</span><span class="n">Path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w">    </span><span class="c1">// Clearing out all previous vertice, because we find the new optimal one</span>
<span class="w">                    </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Vertex</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">node</span><span class="p">));</span><span class="w">    </span><span class="c1">// Insert the new one into the T[W].Path</span>
<span class="w">                    </span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">V</span><span class="p">;</span>
<span class="w">                    </span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">[</span><span class="n">W</span><span class="p">].</span><span class="n">Path</span><span class="p">;</span>
<span class="w">                    </span><span class="n">T</span><span class="p">[</span><span class="n">W</span><span class="p">].</span><span class="n">Path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">T</span><span class="p">[</span><span class="n">W</span><span class="p">].</span><span class="n">Dist</span><span class="p">)</span><span class="w">  </span><span class="c1">// If the new distance is equal to the old one, then just involve the new solution</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Vertex</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">node</span><span class="p">));</span><span class="w">    </span><span class="c1">// The same operations</span>
<span class="w">                    </span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">V</span><span class="p">;</span>
<span class="w">                    </span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">[</span><span class="n">W</span><span class="p">].</span><span class="n">Path</span><span class="p">;</span>
<span class="w">                    </span><span class="n">T</span><span class="p">[</span><span class="n">W</span><span class="p">].</span><span class="n">Path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w">     </span><span class="c1">// Finding the next one</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
</details>
<h4 id="graphs-with-negative-edge-costs">Graphs with Negative Edge Costs<a class="headerlink" href="#graphs-with-negative-edge-costs" title="Permanent link">&para;</a></h4>
<p>如果出现负的边成本，那么我们就不能在使用<code>Known</code>字段标记是否已经处理过某个顶点，因为有可能在第一次处理该顶点之后，又发现更小的路径长度（因为负的边），需要重复处理某个顶点</p>
<details class="info" open="open">
<summary>一种尝试❌</summary>
<p>给所有边<u>加上一个相同的正常数</u>，使得所有边的成本为正数</p>
<p>分析：这样做的话，原本包含边数较多的路径，它的成本增长就明显多于边数较少的路径，这就有可能改变最短路径的取法。</p>
<blockquote>
<p>然而，若所有边的权重都<u>乘上一个相同的正常数</u>，这不影响最短路的结果</p>
</blockquote>
</details>
<p>我们用“无权重最短路算法 + Dijkstra算法”来解决这一问题：</p>
<details class="code">
<summary>代码实现</summary>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">WeightedNegative</span><span class="p">(</span><span class="n">Table</span><span class="w"> </span><span class="n">T</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Queue</span><span class="w"> </span><span class="n">Q</span><span class="p">;</span>
<span class="w">    </span><span class="n">Vertex</span><span class="w"> </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">W</span><span class="p">;</span>
<span class="w">    </span><span class="n">Q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CreateQueue</span><span class="p">(</span><span class="n">NumVertex</span><span class="p">);</span>
<span class="w">    </span><span class="n">MakeEmpty</span><span class="p">(</span><span class="n">Q</span><span class="p">);</span>
<span class="w">    </span><span class="n">Enqueue</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="w"> </span><span class="n">Q</span><span class="p">);</span><span class="w"> </span><span class="c1">// Enqueue the source vertex</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">IsEmpty</span><span class="p">(</span><span class="n">Q</span><span class="p">))</span><span class="w"> </span><span class="c1">// each vertex can dequeue at most |V| times</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">V</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Dequeue</span><span class="p">(</span><span class="n">Q</span><span class="p">);</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">each</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="n">adjacent</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">V</span><span class="p">].</span><span class="n">Dist</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Cvw</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">T</span><span class="p">[</span><span class="n">W</span><span class="p">].</span><span class="n">Dist</span><span class="p">)</span><span class="w"> </span><span class="c1">// no longer once per edge</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">T</span><span class="p">[</span><span class="n">W</span><span class="p">].</span><span class="n">Dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="p">[</span><span class="n">V</span><span class="p">].</span><span class="n">Dist</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Cvw</span><span class="p">;</span>
<span class="w">                </span><span class="n">T</span><span class="p">[</span><span class="n">W</span><span class="p">].</span><span class="n">Path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">V</span><span class="p">;</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">W</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">already</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">Q</span><span class="p">)</span>
<span class="w">                    </span><span class="n">Enqueue</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="w"> </span><span class="n">Q</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="c1">// end-if update</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="c1">// end-while</span>
<span class="w">    </span><span class="n">DisposeQueue</span><span class="p">(</span><span class="n">Q</span><span class="p">);</span><span class="w"> </span><span class="c1">// free memory</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// negative-cost cycle will cause indefinite loop</span>
</code></pre></div>
</details>
<ul>
<li>时间复杂度：<span class="arithmatex">\(O(|E| \cdot |V|)\)</span></li>
<li>如果出现<a href="#single-source-shortest-path-problem"><strong>负值环</strong></a>，该算法将会陷入无限循环。因此，记录每个顶点的出队次数，发现有顶点出队次数多于 <span class="arithmatex">\(|V|\)</span> 次时，就终止程序，这样可以避免这一问题</li>
</ul>
<h4 id="acyclic-graphs">Acyclic Graphs<a class="headerlink" href="#acyclic-graphs" title="Permanent link">&para;</a></h4>
<p>如果图是<em>无环(acyclic)</em>，我们可以按照拓扑序选择顶点，因为当选择某个顶点后，它的距离不可能因为它前面顶点的入边而减少，这样只需执行一趟算法即可。</p>
<p>时间复杂度<span class="arithmatex">\(T = O(|E| + |V|)\)</span>，不需要优先队列</p>
<hr />
<p>应用：<strong>关键路径分析(critical path analysis)</strong></p>
<ul>
<li>AOV网：每个顶点表示一个活动，且包括需要完成该活动的时间。边(v, w) 表示 w 完成之前，v必须完成</li>
</ul>
<div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240508_152235.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240508_152235.png" width="70%" style="margin: 0 auto;"></a>
</div>

<ul>
<li>
<p><strong>AOE网(activity on edges networks)</strong></p>
<p><div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240508_152702.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240508_152702.png" width="70%" style="margin: 0 auto;"></a>
</div></p>
<p>表示方法：</p>
<p><div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240508_140200.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240508_140200.png" width="70%" style="margin: 0 auto;"></a>
</div></p>
<blockquote>
<p>注：必要时需要添加dummy edges和dummy nodes，避免错误或缺少的依赖关系产生</p>
</blockquote>
</li>
</ul>
<div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240508_140331.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240508_140331.png" width="50%" style="margin: 0 auto;"></a>
</div>

<ul>
<li><span class="arithmatex">\(EC[j]\)</span>：节点<span class="arithmatex">\(v_j\)</span> <strong>最早</strong>的完成时间</li>
<li><span class="arithmatex">\(LC[j]\)</span>：节点<span class="arithmatex">\(v_j\)</span> <strong>最晚</strong>的完成时间</li>
</ul>
<p>🌰</p>
<div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240508_140626.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240508_140626.png" width="80%" style="margin: 0 auto;"></a>
</div>

<blockquote>
<p>注：蓝字表示EC，红字表示LC，绿字表示<em>空闲时间</em>（后面会讲到）</p>
</blockquote>
<ul>
<li>
<p>计算EC：找到第一个事件到最后一个事件之间<em>最长</em>的路</p>
<blockquote>
<p>注： 图如果是有环的，因为<strong>正成本环(positive-cost cycles)</strong>的存在，这种算法无法实现。然而这里已经规定是无环图，所以无需担心</p>
</blockquote>
<p>从起点 <span class="arithmatex">\(v_0\)</span> 开始，对于任意的 <span class="arithmatex">\(a_i = &lt;v, w&gt;\)</span>，我们有</p>
<div class="arithmatex">\[
EC[0] = 0 \quad EC[w] = \max\limits_{(v,w) \in E} \{EC[v] + C_{v, w}\}
\]</div>
<blockquote>
<p>按<strong>拓扑序</strong>计算</p>
</blockquote>
</li>
<li>
<p>计算 LC：从终点 <span class="arithmatex">\(v_8\)</span> 开始，对于任意的 <span class="arithmatex">\(a_i = &lt;v, w&gt;\)</span>，我们有</p>
<div class="arithmatex">\[
LC[8] = EC[8] \quad LC[v] = \min\limits_{(v,w) \in E} \{LC[v] - C_{v, w}\}
\]</div>
<blockquote>
<p>按<strong>逆向拓扑序</strong>计算</p>
</blockquote>
</li>
<li>
<p><span class="arithmatex">\(&lt;v, w&gt;\)</span> 的<strong>空闲时间(slack time)</strong> = <span class="arithmatex">\(LC[w] - EC[v] - C_{v, w}\)</span></p>
</li>
<li><strong>关键活动(critical activity)</strong>：空闲时间为0的活动</li>
<li><strong>关键路径(critical path)</strong>：所有边的空闲时间均为0的路径</li>
</ul>
<h3 id="all-pairs-shortest-path-problem">All-pairs Shortest Path Problem<a class="headerlink" href="#all-pairs-shortest-path-problem" title="Permanent link">&para;</a></h3>
<p>对图中任意一对顶点 <span class="arithmatex">\(v_i, v_j(i \ne j)\)</span>，要求它们的最短路径，有以下方法：</p>
<ul>
<li>使用 <span class="arithmatex">\(|V|\)</span> 次<strong>单源算法</strong>（比如 Dijkstra），时间复杂度 <span class="arithmatex">\(T = O(|V|^3)\)</span>，在<em>稀疏图</em>中运行较快</li>
<li>用 Chap 10 给出的算法，时间复杂度 <span class="arithmatex">\(T = O(|V|^3)\)</span>，在<em>稠密图</em>中运行较快，这里就略过了<span class="heimu">我也不知道是什么算法(doge)</span></li>
</ul>
<h2 id="network-flow-problems">Network Flow Problems<a class="headerlink" href="#network-flow-problems" title="Permanent link">&para;</a></h2>
<p>考虑下面的管道网络：</p>
<div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240508_142217.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240508_142217.png" width="30%" style="margin: 0 auto;"></a>
</div>

<ul>
<li>这是一个有向图 <span class="arithmatex">\(G(V, E)\)</span>，每条边的<strong>容量(capacity)</strong>为 <span class="arithmatex">\(c_{v, w}\)</span>，经过该边的<strong>流量(flow)</strong>不得超过它的容量</li>
<li>我们称起点 s 为<strong>源点(source)</strong>，终点 t 为<strong>汇点(sink)</strong></li>
<li>对于所有顶点 <span class="arithmatex">\(v \notin \{s, t\}\)</span>，总流入 = 总流出，即 <span class="arithmatex">\(\text{Total coming in}(v) \equiv \text{Total going out}(v)\)</span>，也就是说顶点<strong>不具备存储的能力</strong></li>
</ul>
<p>🎯：确定从 s 到 t 的<strong>最大流(maximum-flow)</strong></p>
<h3 id="simple-algorithm">Simple Algorithm<a class="headerlink" href="#simple-algorithm" title="Permanent link">&para;</a></h3>
<div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240625_170820.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240625_170820.png" width="70%" style="margin: 0 auto;"></a>
</div>

<p>注：使用这个算法时，我们需要3张图：</p>
<ul>
<li>原图 <span class="arithmatex">\(G\)</span></li>
<li><strong>流量(flow)图</strong> <span class="arithmatex">\(G_f\)</span>：表示算法运行的每个阶段中已经得到的流量，初始情况下每条边的流量均为 0</li>
<li><strong>残量(residual)图</strong> <span class="arithmatex">\(G_r\)</span>：表示对于图中的每条边，还剩下多少流量可以被添加</li>
</ul>
<div class="admonition note">
<p class="admonition-title">步骤</p>
<ol>
<li>在<strong>残量图(residual graph)</strong> <span class="arithmatex">\(G_r\)</span> 中找一条 <span class="arithmatex">\(s \rightarrow t\)</span> 的简单路径，该路径称为<strong>增广路径(augmenting path)</strong></li>
<li>增广路径的流量为路径上的所有边中最小的流量，用该流量更新<strong>流量图(flow graph)</strong> <span class="arithmatex">\(G_f\)</span></li>
<li>更新 <span class="arithmatex">\(G_r\)</span>，并移除流量为0的边</li>
<li>如果 <span class="arithmatex">\(G_r\)</span>中还存在 <span class="arithmatex">\(s \rightarrow t\)</span> 的路径，回到步骤 1，否则终止程序</li>
</ol>
</div>
<details class="play" open="open">
<summary>动画演示</summary>
<p><div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/8.gif" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/8.gif" width="70%" style="margin: 0 auto;"></a>
</div></p>
</details>
<div class="admonition warning">
<p class="admonition-title">问题</p>
<p>如果我们采用<strong>贪心</strong>的策略，对于上图，我们会先选择<span class="arithmatex">\(s \rightarrow a \rightarrow d \rightarrow t\)</span>，这样得到的流量为 3，如下图所示。然而，这样做的话我们就无法再找到第 2 条路径，因此总流量为3，不满足要求。因此我们需要改进上述算法。</p>
<p><div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240508_154736.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240508_154736.png" width="80%" style="margin: 0 auto;"></a>
</div></p>
</div>
<h3 id="solution">Solution<a class="headerlink" href="#solution" title="Permanent link">&para;</a></h3>
<div class="admonition info">
<p class="admonition-title">改进</p>
<p>让算法具备<strong>撤销(undo)</strong>决策的能力：对于流量图 <span class="arithmatex">\(G_f\)</span> 中的每条边 (v, w)，它的流量为 <span class="arithmatex">\(f_{v, w}\)</span>，在<strong>残量图</strong>中添加一条反向的边 (w, v)，它的流量也为 <span class="arithmatex">\(f_{v, w}\)</span></p>
</div>
<p>令 <span class="arithmatex">\(f\)</span> 表示图 <span class="arithmatex">\(G = (V, E)\)</span> 的流量，则残差图的边的权重为：</p>
<div class="arithmatex">\[
r(u, v) = \begin{cases}r(u, v) - f(u, v) &amp; \text{if }(u, v) \in E \\ f(v, u) &amp; \text{if }(v, u) \in E \\ 0 &amp; \text{otherwise}\end{cases}
\]</div>
<details class="play" open="open">
<summary>动画演示</summary>
<p><div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/9.gif" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/9.gif" width="80%" style="margin: 0 auto;"></a>
</div></p>
</details>
<p>最终效果：</p>
<div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240625_171232.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240625_171232.png" width="80%" style="margin: 0 auto;"></a>
</div>

<blockquote>
<p>注：如果边的容量是<em>有理数</em>，那么该算法在终止时总能得到一个最大流（图有<strong>环</strong>的话也可以）</p>
</blockquote>
<h3 id="analysis">Analysis<a class="headerlink" href="#analysis" title="Permanent link">&para;</a></h3>
<blockquote>
<p>前提：所有边的容量为整数</p>
</blockquote>
<p>我们可以利用<a href="#unweighted-shortest-paths"><strong>无权最短路径算法</strong></a>来找到<strong>增广路径</strong></p>
<blockquote>
<p>时间复杂度 <span class="arithmatex">\(T = O(f \cdot |E|)\)</span>，<span class="arithmatex">\(f\)</span>表示最大流量</p>
</blockquote>
<p>但对于以下特殊情况：</p>
<div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240508_145431.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240508_145431.png" width="60%" style="margin: 0 auto;"></a>
</div>

<p>如果我们随机挑选增广路径，挑到一条包括 <span class="arithmatex">\(a \rightarrow b\)</span> 的路径，就会产生问题：</p>
<blockquote>
<p>Random augmentations could continually augment along a path that includes the edge connected by a and b. If this were to occur repeatedly, 2,000,000 augmentations would be required, when we could get by with only 2.</p>
</blockquote>
<div class="admonition note">
<p class="admonition-title">解决方法</p>
<div class="tabbed-set tabbed-alternate" data-tabs="6:2"><input checked="checked" id="__tabbed_6_1" name="__tabbed_6" type="radio" /><input id="__tabbed_6_2" name="__tabbed_6" type="radio" /><div class="tabbed-labels"><label for="__tabbed_6_1">法1</label><label for="__tabbed_6_2">法2</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>在选择增广路径时，总是挑选<strong>对流量提升最大</strong>的路径</p>
<p>如何实现：稍微改变一下 Dijkstra 算法</p>
<p>时间复杂度：</p>
<div class="arithmatex">\[
\begin{align}
T = &amp; T_{augmentation} \cdot T_{find\ a\ path} \notag \\
= &amp; O(|E| \log cap_{max}) \cdot O(|E|\log |V|) \notag \\
= &amp; O(|E|^2 \log |V|) (\text{if } cap_{max} \text{ is a small integer}) \notag
\end{align}
\]</div>
</div>
<div class="tabbed-block">
<p>在选择增广路径时，挑选<strong>边最少</strong>的增广路径</p>
<p>时间复杂度：</p>
<div class="arithmatex">\[
\begin{align}
T = &amp; T_{augmentation} \cdot T_{find\ a\ path} \notag \\
= &amp; O(|E|) \cdot O(|E| \cdot |V|)\quad (\text{unweighted shortest path algorithm}) \notag \\
= &amp; O(|E|^2 |V|) \notag
\end{align}
\]</div>
</div>
</div>
</div>
</div>
<h3 id="supplements">Supplements<a class="headerlink" href="#supplements" title="Permanent link">&para;</a></h3>
<ul>
<li>更优的算法，时间复杂度可以将至 <span class="arithmatex">\(O(|E||V|\log(|V|^2/|E|))\)</span>和<span class="arithmatex">\(O(|E||V| + |V|^{2 + \epsilon})\)</span></li>
<li>对于某些特殊情况，时间复杂度还可以降低：如果除了源点和汇点外的所有顶点的入边容量为1，或者出边容量为 1，那么最优算法的时间复杂度为 <span class="arithmatex">\(O(|E||V|^{\frac{1}{2}})\)</span></li>
<li>更复杂的问题：<em>最小费用流问题(min-cost flow problem)</em>——每条边不仅有容量，还要考虑单位流量的费用。🎯：要找到所有最大流量中的最小成本</li>
</ul>
<h2 id="minimum-spanning-tree">Minimum Spanning Tree<a class="headerlink" href="#minimum-spanning-tree" title="Permanent link">&para;</a></h2>
<p>定义：图 <span class="arithmatex">\(G\)</span> 的<strong>生成树(spanning tree)</strong>是一棵包含所有顶点 <span class="arithmatex">\(V(G)\)</span>（但不一定包含所有边）的树</p>
<p>🌰：</p>
<div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240508_150633.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240508_150633.png" width="60%" style="margin: 0 auto;"></a>
</div>

<p>如何理解<strong>最小生成树(minimum spanning tree)</strong>？</p>
<ul>
<li>
<p>“树”：无环且边的数量为 |V| - 1</p>
<blockquote>
<p>因此当图的边数 &lt; |V| - 1时，该图不存在最小生成树</p>
</blockquote>
</li>
<li>
<p>“最小”：保证生成树的所有边的权重和最小</p>
</li>
<li>“生成”：覆盖所有的顶点</li>
<li>最小生成树存在的<strong>充要条件</strong>是图<span class="arithmatex">\(G\)</span>是<strong>连通的</strong></li>
<li>如果在生成树中添加一条边，就会形成一个<em>环</em></li>
<li>最小生成树是并不一定是唯一的，但最小生成树的<strong>总权重是唯一的</strong></li>
</ul>
<p>如何求解？——<strong>贪心算法(greedy algorithm)</strong>，每一步都采取最优策略，但有以下限制：</p>
<ul>
<li>必须使用图里面的边</li>
<li>必须用到 <span class="arithmatex">\(|V| - 1\)</span> 条边</li>
<li>不能出现环</li>
</ul>
<h3 id="prims-algorithm">Prim's Algorithm<a class="headerlink" href="#prims-algorithm" title="Permanent link">&para;</a></h3>
<p>方法：生成一棵树，与 Dijkstra 算法非常相似，适用于<strong>稠密图</strong>中</p>
<ul>
<li>初始情况下，先将一个顶点作为树的<strong>根</strong>放入树内</li>
<li>在每个阶段，添加边(u, v)，满足 (u, v) 的权重是来自已有生成树的顶点 u 和来自生成树外的 v 之间的所有边中权重最小的那条，且不产生环，然后将新的顶点 v添加至树里</li>
<li>重复上述步骤，直至所有顶点均在生成树内</li>
</ul>
<details class="play" open="open">
<summary>动画演示</summary>
<p><div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/10.gif" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/10.gif" width="60%" style="margin: 0 auto;"></a>
</div></p>
</details>
<p>与Dijkstra不同之处在于：</p>
<ul>
<li>
<p>要保存两类值 <span class="arithmatex">\(d_v\)</span> 和 <span class="arithmatex">\(p_v\)</span>：</p>
<ul>
<li><span class="arithmatex">\(d_v\)</span>：连接 <span class="arithmatex">\(v\)</span> 和已知顶点的最短路的权重</li>
<li><span class="arithmatex">\(p_v\)</span>：最后一个导致 <span class="arithmatex">\(d_v\)</span> 改变的顶点</li>
</ul>
</li>
<li>
<p>更新规则更加简单：对于已经选入树内的顶点 <span class="arithmatex">\(v\)</span>，它的邻接顶点 <span class="arithmatex">\(w\)</span> 满足 <span class="arithmatex">\(d_w = \min(d_w, c_{w, v})\)</span></p>
</li>
</ul>
<blockquote>
<p>注：由于这是无向图，因此需要用到<u>两张邻接表</u>存储图</p>
</blockquote>
<p>时间复杂度：</p>
<ul>
<li>不用堆（适用于<em>稠密图</em>）：<span class="arithmatex">\(O(|V|^2)\)</span></li>
<li><em>二叉堆</em>（适用于<em>稀疏图</em>）：<span class="arithmatex">\(O(E\log|V|)\)</span></li>
</ul>
<details class="code">
<summary>代码实现</summary>
<div class="highlight"><pre><span></span><code><span class="cm">/*</span>
<span class="cm">* Function: prim</span>
<span class="cm">* --------------</span>
<span class="cm">*   Find a minimum spanning tree for the given undirected</span>
<span class="cm">*   graph by using Prim&#39;s algorithm</span>
<span class="cm">*</span>
<span class="cm">*   w_adj_mat: the weighted adjacency matrix</span>
<span class="cm">*   n: the number of vertices</span>
<span class="cm">*</span>
<span class="cm">*   returns: the total edge weights of the MST</span>
<span class="cm">*/</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">prim</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">w_adj_mat</span><span class="p">[</span><span class="n">MAX</span><span class="p">][</span><span class="n">MAX</span><span class="p">],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="kt">int</span><span class="w"> </span><span class="n">dist</span><span class="p">[</span><span class="n">MAX</span><span class="p">];</span><span class="w"> </span><span class="c1">// distance from vertex i to the known part</span>
<span class="kt">int</span><span class="w"> </span><span class="n">prev</span><span class="p">[</span><span class="n">MAX</span><span class="p">];</span><span class="w"> </span><span class="c1">// for tracing the edges of MST</span>
<span class="kt">int</span><span class="w"> </span><span class="n">known</span><span class="p">[</span><span class="n">MAX</span><span class="p">];</span><span class="w"> </span><span class="c1">// 1 if the vertex i is checked, 0 if not</span>

<span class="c1">// initialization</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INFINITY</span><span class="p">;</span>
<span class="w">    </span><span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="n">known</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// start from vertex 0</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// choose the vertex closest to the known part</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">min_d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INFINITY</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">min_v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">known</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">min_d</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">min_d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="n">min_v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// relaxation of vertices adjacent to the chosen one</span>
<span class="w">    </span><span class="n">known</span><span class="p">[</span><span class="n">min_v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">known</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">w_adj_mat</span><span class="p">[</span><span class="n">min_v</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">w_adj_mat</span><span class="p">[</span><span class="n">min_v</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">        </span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">w_adj_mat</span><span class="p">[</span><span class="n">min_v</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min_v</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// total edge weights</span>
<span class="kt">int</span><span class="w"> </span><span class="n">total_w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">    </span><span class="n">total_w</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="k">return</span><span class="w"> </span><span class="n">total_w</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
</details>
<h3 id="kruskals-algorithm">Kruskal's Algorithm<a class="headerlink" href="#kruskals-algorithm" title="Permanent link">&para;</a></h3>
<p>方法：维持一片森林（一组树），适用于<strong>稀疏图</strong>中</p>
<ul>
<li>初始情况下，有 <span class="arithmatex">\(|V|\)</span> 棵单个节点构成的树</li>
<li>添加一条边，可以合并两棵树。当算法结束时，应当只剩下一棵树。因此，我们很自然地想到使用<strong>并查集</strong>的算法</li>
<li>
<p>挑选边（这里假设挑选边 <span class="arithmatex">\((u, v)\)</span> ）时要注意的细节：</p>
<ul>
<li>如果 u, v 在同一个集合内，则不能添加这条边（否则会出现环）</li>
<li>否则加入这条边，使用 <code>Union</code> 算法将两个集合合并起来</li>
<li>用<strong>堆</strong>维护未被检验过的最小的边，每当检验一条边时，使用 <code>DeleteMin</code> 算法</li>
</ul>
</li>
</ul>
<p>图示：</p>
<div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240508_194123.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240508_194123.png" width="80%" style="margin: 0 auto;"></a>
</div>

<p>伪代码实现：</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">Kruskal</span><span class="p">(</span><span class="n">Graph</span><span class="w"> </span><span class="n">G</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">contains</span><span class="w"> </span><span class="n">less</span><span class="w"> </span><span class="n">than</span><span class="w"> </span><span class="p">[</span><span class="n">V</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">edges</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">empty</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">choose</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">least</span><span class="w"> </span><span class="n">cost</span><span class="w"> </span><span class="n">edge</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">E</span><span class="p">;</span><span class="w"> </span><span class="c1">// DeleteMin</span>
<span class="w">        </span><span class="n">delete</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">E</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="n">does</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">create</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">cycle</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">T</span><span class="p">)</span>
<span class="w">            </span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">T</span><span class="p">;</span><span class="w"> </span><span class="c1">// Union/Find</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">discard</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">contains</span><span class="w"> </span><span class="n">fewer</span><span class="w"> </span><span class="n">than</span><span class="w"> </span><span class="p">[</span><span class="n">V</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">edges</span><span class="p">)</span>
<span class="w">        </span><span class="n">Error</span><span class="p">(</span><span class="s">&quot;No spanning tree&quot;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<details class="code">
<summary>正式代码实现</summary>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">Kruskal</span><span class="p">(</span><span class="n">Graph</span><span class="w"> </span><span class="n">G</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">EdgesAccepted</span><span class="p">;</span>
<span class="w">    </span><span class="n">DisjSet</span><span class="w"> </span><span class="n">S</span><span class="p">;</span>
<span class="w">    </span><span class="n">PriorityQueue</span><span class="w"> </span><span class="n">H</span><span class="p">;</span>
<span class="w">    </span><span class="n">Vertex</span><span class="w"> </span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">;</span>
<span class="w">    </span><span class="n">SetType</span><span class="w"> </span><span class="n">Uset</span><span class="p">,</span><span class="w"> </span><span class="n">Vset</span><span class="p">;</span>
<span class="w">    </span><span class="n">Edge</span><span class="w"> </span><span class="n">E</span><span class="p">;</span>

<span class="w">    </span><span class="n">Initialize</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
<span class="w">    </span><span class="n">ReadGraphIntoHeapArray</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="w"> </span><span class="n">H</span><span class="p">);</span>
<span class="w">    </span><span class="n">BuildHeap</span><span class="p">(</span><span class="n">H</span><span class="p">);</span>

<span class="w">    </span><span class="n">EdgeAccepted</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">EdgesAccepted</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NumVertex</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DeleteMin</span><span class="p">(</span><span class="n">H</span><span class="p">);</span><span class="w">  </span><span class="c1">// E = (U, V)</span>
<span class="w">        </span><span class="n">Uset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Find</span><span class="p">(</span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="n">S</span><span class="p">);</span>
<span class="w">        </span><span class="n">Vset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Find</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">S</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Uset</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">Vset</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Accept the edge</span>
<span class="w">            </span><span class="n">EdgesAccepted</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="n">SetUnion</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="w"> </span><span class="n">Uset</span><span class="p">,</span><span class="w"> </span><span class="n">Vset</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
</details>
<p>由于每条边要存 3 个字段，因此用<em>指针数组</em>存储边可能更加高效。</p>
<p>时间复杂度：<span class="arithmatex">\(T = O(|E|\log |E|) = O(|E| \log |V|) \quad (|E| = O(|V|^2))\)</span></p>
<h2 id="applications-of-depth-first-search">Applications of Depth-First Search<a class="headerlink" href="#applications-of-depth-first-search" title="Permanent link">&para;</a></h2>
<p><strong>深度优先搜索(depth-first search, DFS)</strong>是一种<u>前序遍历</u>的泛化</p>
<ul>
<li>树：时间复杂度 <span class="arithmatex">\(T = O(|E|)\ (|E| = \Theta(|V|))\)</span></li>
<li>图：注意要避免环(cycles)，所以访问过的顶点就要对其<strong>标记</strong>，然后接着访问未访问过的顶点。</li>
<li>如果无向图不连通，或者有向图不是强连通的，那么用一次 DFS 无法访问所有顶点，需要对未标记的顶点再用一次 DFS，直至所有顶点都被标记。因此，时间复杂度为 <span class="arithmatex">\(O(|E| + |V|)\)</span></li>
</ul>
<p>模版：
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">DFS</span><span class="p">(</span><span class="n">Vertex</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">visited</span><span class="p">[</span><span class="n">V</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="c1">// mark this vertex to void cycles</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">each</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="n">adjacent</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">W</span><span class="p">])</span>
<span class="w">            </span><span class="n">DFS</span><span class="p">(</span><span class="n">W</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="undirected-graphs">Undirected Graphs<a class="headerlink" href="#undirected-graphs" title="Permanent link">&para;</a></h3>
<p>当且仅当 1 次 DFS 能够遍历所有顶点时，无向图是连通的</p>
<div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/2.gif" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/2.gif" width="60%" style="margin: 0 auto;"></a>
</div>

<p>我们可以使用<strong>深度优先生成树(depth-first spanning tree)</strong>来形象展示 DFS 的过程。当我们发现某条边(v, w) 中的 w 已被标记过，用虚线画出这条边，称作“<strong>回边(back edge)</strong>”，表示这条边不包含于生成树里，如图所示：</p>
<div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/2.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/2.png" width="80%" style="margin: 0 auto;"></a>
</div>

<p>如果无向图不连通，则可以生成<em>深度优先生成森林(depth-first spanning forest)</em></p>
<p>代码实现：
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">ListComponents</span><span class="p">(</span><span class="n">Graph</span><span class="w"> </span><span class="n">G</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">each</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">G</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">V</span><span class="p">])</span>
<span class="w">            </span><span class="n">DFS</span><span class="p">(</span><span class="n">V</span><span class="p">);</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="biconnectivity">Biconnectivity<a class="headerlink" href="#biconnectivity" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p>当<code>G' = DeleteVertex(G, v)</code>至少有 2 个连通分量时，称<code>v</code>为<strong>关节点(articulation point)</strong>或者<strong>割点(cut vertex)</strong></p>
<blockquote>
<p>换句话说，关节点的移除能够破坏图的连通性</p>
</blockquote>
</li>
<li>
<p>没有关节点的连通图 <code>G</code> 称为<strong>双连通图(biconnected graph)</strong></p>
<blockquote>
<p>注：之所以称为双连通图，是因为至少需要移除两个及以上的顶点，才能形成有多个连通分量的子图</p>
</blockquote>
</li>
<li>
<p><strong>双连通分量(biconnected component)</strong>：极大双连通子图</p>
</li>
</ul>
<div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240515_150434.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240515_150434.png" width="80%" style="margin: 0 auto;"></a>
</div>

<blockquote>
<p>注：没有一条边会同时出现在多个双连通分量中。因此 E(G) 被双连通分量划分，而双连通分量又被关节点划分</p>
</blockquote>
<div class="admonition question">
<p class="admonition-title">问题</p>
<p>寻找无向连通图 G 中的<strong>双连通分量的个数 = 关节点的个数 + 1</strong></p>
</div>
<div class="admonition note">
<p class="admonition-title">解决方法</p>
<p>如果题目给出一张图，叫我们找出所有关节点，这只要对每个顶点进行判断（假设移除某个顶点后，会不会多一些连通分量），很容易地找到所有关节点。但下面我们要用程序来解决这一问题</p>
<p>用到的变量：</p>
<ul>
<li><code>Num(v)</code>：顶点 v 的 DFS 序号</li>
<li><code>Low(v)</code>：生成树中顶点 v 的所有孩子节点以及 v 回边上的顶点中 <code>Num</code> 的最小值(<span class="arithmatex">\(\min(Num(w_i))\)</span>)（用到<strong>后序遍历</strong>）</li>
</ul>
<hr />
<ul>
<li>
<p>使用<strong>深度优先搜索(depth first search)</strong>得到G的生成树</p>
<details class="play" open="open">
<summary>动画演示</summary>
<p><div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/3.gif" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/3.gif" width="70%" style="margin: 0 auto;"></a>
</div></p>
</details>
<p>我们得到：</p>
<p><div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240515_152220.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240515_152220.png" width="40%" style="margin: 0 auto;"></a>
</div></p>
<p><strong>回边(back edges)</strong>(u, v)：在图中而不在生成树内的边(u, v)，它反映了 u 和 v 之间有祖辈和后辈的关系。如果 u 是 v 的祖先，则 <code>Num(u) &lt; Num(v)</code>；反之 <code>Num(u) &gt; Num(v)</code></p>
<p><code>Low(u)</code> 的计算公式：</p>
<div class="arithmatex">\[
\begin{align}
Low(u) = &amp; \min\{Num(u), \min\{Low(w)\ |\ w \text{ is a child of }u\} \notag \\
&amp; , \min\{Num(w)\ |\ (u, w) \text{ is a back edge}\}\} \notag
\end{align}
\]</div>
<p>表格（记录了<code>Num(v)</code>和<code>Low(v)</code>）：</p>
<p><div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/Quicker_20240515_153001.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/Quicker_20240515_153001.png" width="70%" style="margin: 0 auto;"></a>
</div></p>
</li>
<li>
<p>找到G内的<strong>关节点</strong></p>
<ul>
<li>当且仅当<strong>根节点</strong>至少有 2 个孩子时，根节点为关节点</li>
<li>当且仅当<strong>除根节点外的顶点u</strong>至少有 1 个孩子，且该孩子与它的祖先之间没有回边（即<code>Low(child) &gt;= Num(u)</code>）时，u 为关节点</li>
</ul>
</li>
</ul>
</div>
<details class="code">
<summary>代码实现</summary>
<div class="highlight"><pre><span></span><code><span class="c1">// Assign Num and compute Parents</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">AssignNum</span><span class="p">(</span><span class="n">Vertex</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Vertex</span><span class="w"> </span><span class="n">W</span><span class="p">;</span>

<span class="w">    </span><span class="n">Num</span><span class="p">[</span><span class="n">V</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Counter</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="n">Visited</span><span class="p">[</span><span class="n">V</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ture</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="n">adjacent</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">V</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Visited</span><span class="p">[</span><span class="n">W</span><span class="p">])</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">Parent</span><span class="p">[</span><span class="n">W</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">V</span><span class="p">;</span>
<span class="w">            </span><span class="n">AssignNum</span><span class="p">(</span><span class="n">W</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Assign Low; also check for articulation points</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">AssignLow</span><span class="p">(</span><span class="n">Vertex</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Vertex</span><span class="w"> </span><span class="n">W</span><span class="p">;</span>

<span class="w">    </span><span class="n">Low</span><span class="p">[</span><span class="n">V</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Num</span><span class="p">[</span><span class="n">V</span><span class="p">];</span><span class="w"> </span><span class="c1">// Rule 1</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="n">adjacent</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">V</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Num</span><span class="p">[</span><span class="n">W</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">Num</span><span class="p">[</span><span class="n">V</span><span class="p">])</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">AssignLow</span><span class="p">(</span><span class="n">W</span><span class="p">);</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Low</span><span class="p">[</span><span class="n">W</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">Num</span><span class="p">[</span><span class="n">V</span><span class="p">])</span>
<span class="w">                </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%v is an articulation point</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">);</span>
<span class="w">            </span><span class="n">Low</span><span class="p">[</span><span class="n">V</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Min</span><span class="p">(</span><span class="n">Low</span><span class="p">[</span><span class="n">V</span><span class="p">],</span><span class="w"> </span><span class="n">Low</span><span class="p">[</span><span class="n">W</span><span class="p">]);</span><span class="w">  </span><span class="c1">// Rule 3</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Parent</span><span class="p">[</span><span class="n">V</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">W</span><span class="p">)</span>
<span class="w">            </span><span class="n">Low</span><span class="p">[</span><span class="n">V</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Min</span><span class="p">(</span><span class="n">Low</span><span class="p">[</span><span class="n">V</span><span class="p">],</span><span class="w"> </span><span class="n">Num</span><span class="p">[</span><span class="n">W</span><span class="p">]);</span><span class="w">  </span><span class="c1">// Rule 2</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Testing for articulation points in one depth-first search</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">FindArt</span><span class="p">(</span><span class="n">Vertex</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Vertex</span><span class="w"> </span><span class="n">W</span><span class="p">;</span>

<span class="w">    </span><span class="n">Visited</span><span class="p">[</span><span class="n">V</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">True</span>
<span class="w">    </span><span class="n">Low</span><span class="p">[</span><span class="n">V</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Num</span><span class="p">[</span><span class="n">V</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Counter</span><span class="p">;</span><span class="w"> </span><span class="c1">// Rule 1</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="n">adjacent</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">V</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">Visited</span><span class="p">[</span><span class="n">W</span><span class="p">])</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">Parent</span><span class="p">[</span><span class="n">W</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">V</span><span class="p">;</span>
<span class="w">            </span><span class="n">FindArt</span><span class="p">(</span><span class="n">W</span><span class="p">);</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Low</span><span class="p">[</span><span class="n">W</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">Num</span><span class="p">[</span><span class="n">V</span><span class="p">])</span>
<span class="w">                </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%v is an articulation point</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">);</span>
<span class="w">            </span><span class="n">Low</span><span class="p">[</span><span class="n">V</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Min</span><span class="p">(</span><span class="n">Low</span><span class="p">[</span><span class="n">V</span><span class="p">],</span><span class="w"> </span><span class="n">Low</span><span class="p">[</span><span class="n">W</span><span class="p">]);</span><span class="w">  </span><span class="c1">// Rule 3</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Parent</span><span class="p">[</span><span class="n">V</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">W</span><span class="p">)</span>
<span class="w">            </span><span class="n">Low</span><span class="p">[</span><span class="n">V</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Min</span><span class="p">(</span><span class="n">Low</span><span class="p">[</span><span class="n">V</span><span class="p">],</span><span class="w"> </span><span class="n">Num</span><span class="p">[</span><span class="n">W</span><span class="p">]);</span><span class="w">  </span><span class="c1">// Rule 2</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
</details>
<h3 id="euler-circuits">Euler Circuits<a class="headerlink" href="#euler-circuits" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>欧拉路(Euler tour)</strong>：在笔不离纸的情况下，图上的每条边均被遍历一遍（一笔画）</li>
<li><strong>欧拉环(Euler circuit)</strong>：在笔不离纸的情况下，图上的每条边均被遍历一遍，且最后回到起点的位置</li>
</ul>
<details class="play">
<summary>动画演示</summary>
<p><div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/4.gif" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/4.gif" width="70%" style="margin: 0 auto;"></a>
</div></p>
</details>
<p>判断方法：</p>
<ul>
<li>无向图：<ul>
<li>当且仅当图是连通的，且<strong>每个顶点的度为偶数</strong>时，存在<strong>欧拉环</strong></li>
<li>当且仅当图是连通的，且<strong>仅有两个顶点的度为奇数</strong>时，存在<strong>欧拉路</strong></li>
</ul>
</li>
<li>有向图：<ul>
<li>当且仅当图是弱连通的，且每个顶点的<strong>出度 = 入度</strong>时，存在<strong>欧拉环</strong></li>
<li>当且仅当图是弱连通的，且有且仅有<strong>一个</strong>顶点的<u>出度 = 入度 + 1</u>，有且仅有<strong>一个</strong>顶点的<u>入度 = 出度 + 1</u>，其余顶点的<u>出度 = 入度</u>时，存在<strong>欧拉路</strong></li>
</ul>
</li>
</ul>
<p>利用<strong>DFS</strong>寻找欧拉环：</p>
<details class="play" open="open">
<summary>动画演示</summary>
<p><div style="text-align: center; margin-top: 15px;">
<a class="glightbox" href="imgs/C9/5.gif" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="imgs/C9/5.gif" width="80%" style="margin: 0 auto;"></a>
</div></p>
</details>
<ul>
<li>用<em>链表</em>维护路径</li>
<li>对于每个邻接表，维护一个指向最后被扫描的边</li>
<li>时间复杂度 <span class="arithmatex">\(T = O(|E| + |V|)\)</span></li>
</ul>
<details class="info">
<summary>补充：<a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%AF%86%E9%A1%BF%E5%9B%BE"><strong>哈密顿环(Hamilton cycle)</strong></a></summary>
<p>无向图中能够访问所有<strong>顶点</strong>的环。</p>
<details class="code">
<summary>代码实现</summary>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>

<span class="cp">#define SIZE 201</span>
<span class="cp">#define PSIZE 2001</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">AdjVNode</span><span class="w"> </span><span class="o">*</span><span class="n">PtrToAdjVNode</span><span class="p">;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">AdjVNode</span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">AdjV</span><span class="p">;</span>
<span class="w">    </span><span class="n">PtrToAdjVNode</span><span class="w"> </span><span class="n">Next</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Vnode</span><span class="p">{</span>
<span class="w">    </span><span class="n">PtrToAdjVNode</span><span class="w"> </span><span class="n">FirstEdge</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">AdjList</span><span class="p">[</span><span class="n">SIZE</span><span class="p">];</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">GNode</span><span class="w"> </span><span class="o">*</span><span class="n">PtrToGNode</span><span class="p">;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">GNode</span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">Nv</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">Ne</span><span class="p">;</span>
<span class="w">    </span><span class="n">AdjList</span><span class="w"> </span><span class="n">G</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">PtrToGNode</span><span class="w"> </span><span class="n">LGraph</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">HCycle</span><span class="p">(</span><span class="n">LGraph</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="w"> </span><span class="p">]);</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="n">v2</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">path</span><span class="p">[</span><span class="n">PSIZE</span><span class="p">];</span>
<span class="w">    </span><span class="n">LGraph</span><span class="w"> </span><span class="n">Graph</span><span class="p">;</span>
<span class="w">    </span><span class="n">PtrToAdjVNode</span><span class="w"> </span><span class="n">cur1</span><span class="p">,</span><span class="w"> </span><span class="n">cur2</span><span class="p">;</span>

<span class="w">    </span><span class="n">Graph</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PtrToGNode</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">GNode</span><span class="p">));</span>
<span class="w">    </span><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d%d&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="w">    </span><span class="n">Graph</span><span class="o">-&gt;</span><span class="n">Nv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="w">    </span><span class="n">Graph</span><span class="o">-&gt;</span><span class="n">Ne</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">Graph</span><span class="o">-&gt;</span><span class="n">G</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">FirstEdge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d%d&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v2</span><span class="p">);</span>
<span class="w">        </span><span class="n">cur1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PtrToAdjVNode</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">AdjVNode</span><span class="p">));</span>
<span class="w">        </span><span class="n">cur1</span><span class="o">-&gt;</span><span class="n">AdjV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v2</span><span class="p">;</span>
<span class="w">        </span><span class="n">cur1</span><span class="o">-&gt;</span><span class="n">Next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Graph</span><span class="o">-&gt;</span><span class="n">G</span><span class="p">[</span><span class="n">v1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">].</span><span class="n">FirstEdge</span><span class="p">;</span>
<span class="w">        </span><span class="n">Graph</span><span class="o">-&gt;</span><span class="n">G</span><span class="p">[</span><span class="n">v1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">].</span><span class="n">FirstEdge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cur1</span><span class="p">;</span>
<span class="w">        </span><span class="n">cur2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PtrToAdjVNode</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">AdjVNode</span><span class="p">));</span>
<span class="w">        </span><span class="n">cur2</span><span class="o">-&gt;</span><span class="n">AdjV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span><span class="p">;</span>
<span class="w">        </span><span class="n">cur2</span><span class="o">-&gt;</span><span class="n">Next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Graph</span><span class="o">-&gt;</span><span class="n">G</span><span class="p">[</span><span class="n">v2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">].</span><span class="n">FirstEdge</span><span class="p">;</span>
<span class="w">        </span><span class="n">Graph</span><span class="o">-&gt;</span><span class="n">G</span><span class="p">[</span><span class="n">v2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">].</span><span class="n">FirstEdge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cur2</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">k</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">q</span><span class="p">);</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">q</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">            </span><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">path</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">q</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">Graph</span><span class="o">-&gt;</span><span class="n">Nv</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;NO</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">HCycle</span><span class="p">(</span><span class="n">Graph</span><span class="p">,</span><span class="w"> </span><span class="n">path</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">HCycle</span><span class="p">(</span><span class="n">LGraph</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="w"> </span><span class="p">])</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">flag</span><span class="p">[</span><span class="n">SIZE</span><span class="p">];</span>
<span class="w">    </span><span class="n">PtrToAdjVNode</span><span class="w"> </span><span class="n">cur</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">g</span><span class="o">-&gt;</span><span class="n">Nv</span><span class="p">])</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;NO</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">g</span><span class="o">-&gt;</span><span class="n">Nv</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">            </span><span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">g</span><span class="o">-&gt;</span><span class="n">Nv</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;NO</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">                </span><span class="k">return</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="o">-&gt;</span><span class="n">G</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">].</span><span class="n">FirstEdge</span><span class="p">;</span>
<span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">cur</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">AdjV</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="w">                </span><span class="n">cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cur</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;NO</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">                </span><span class="k">return</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">flag</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;YES</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
</details>
</details>







  
    
  
  
    
  


  <aside class="md-source-file">
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="最后更新">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1-2.1-2M12.5 7v5.2l4 2.4-1 1L11 13V7h1.5M11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2v1.8Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-datetime">2024年8月18日 09:01:42</span>
  </span>

    
    
      
  <span class="md-source-file__fact">
    <span class="md-icon" title="创建日期">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3h-2Z"/></svg>
    </span>
    <span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-datetime">2024年8月18日 09:01:42</span>
  </span>

    
    
    
      
  <span class="md-source-file__fact">
    
      
  <span class="md-icon" title="贡献者">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34-.46-1.16-1.11-1.47-1.11-1.47-.91-.62.07-.6.07-.6 1 .07 1.53 1.03 1.53 1.03.87 1.52 2.34 1.07 2.91.83.09-.65.35-1.09.63-1.34-2.22-.25-4.55-1.11-4.55-4.92 0-1.11.38-2 1.03-2.71-.1-.25-.45-1.29.1-2.64 0 0 .84-.27 2.75 1.02.79-.22 1.65-.33 2.5-.33.85 0 1.71.11 2.5.33 1.91-1.29 2.75-1.02 2.75-1.02.55 1.35.2 2.39.1 2.64.65.71 1.03 1.6 1.03 2.71 0 3.82-2.34 4.66-4.57 4.91.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2Z"/></svg>
  </span>
  <span>GitHub</span>

    
    <nav>
      
        <a href="https://github.com/IsshikiHugh" class="md-author" title="@IsshikiHugh">
          
          <img src="https://avatars.githubusercontent.com/u/48550237?v=4&size=72" alt="IsshikiHugh">
        </a>
      
        <a href="https://github.com/NoughtQ" class="md-author" title="@NoughtQ">
          
          <img src="https://avatars.githubusercontent.com/u/88835299?v=4&size=72" alt="NoughtQ">
        </a>
      
      
      
    </nav>
  </span>

    
  </aside>





  <h2 id="__comments">评论</h2>


  <!-- TODO: Insert generated snippet here -->
  <script src="https://giscus.app/client.js"
    data-repo="ZIJI-CS/T-FundamentalDataStructure"
    data-repo-id="R_kgDOMhOFnQ"
    data-category="Announcements"
    data-category-id="DIC_kwDOMhOFnc4Chk6Q"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="light"
    data-lang="en"
    crossorigin="anonymous"
    async>
  </script>

  <!-- Synchronize Giscus theme with palette -->
  <script>
    var giscus = document.querySelector("script[src*=giscus]")

    /* Set palette on initial load */
    var palette = __md_get("__palette")
    if (palette && typeof palette.color === "object") {
      var theme = "light"
      giscus.setAttribute("data-theme", theme)
    }

    /* Register event handlers after documented loaded */
    document.addEventListener("DOMContentLoaded", function() {
      var ref = document.querySelector("[data-md-component=palette]")
      ref.addEventListener("change", function() {
        var palette = __md_get("__palette")
        if (palette && typeof palette.color === "object") {
          var theme = "light"

          /* Instruct Giscus to change theme */
          var frame = document.querySelector(".giscus-frame")
          frame.contentWindow.postMessage(
            { giscus: { setConfig: { theme } } },
            "https://giscus.app"
          )
        }
      })
    })
  </script>

                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
  回到页面顶部
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy 2024 ZIJI-CS
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": ".", "features": ["navigation.tabs", "navigation.indexes", "navigation.expand", "navigation.top", "search.highlight", "search.share", "content.action.edit", "content.action.view", "content.code.annotate", "content.code.copy"], "search": "assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="assets/javascripts/bundle.fe8b6f2b.min.js"></script>
      
        <script src="supports/js/xlink.js"></script>
      
        <script src="supports/js/katex.js"></script>
      
        <script src="https://jsd.cdn.zzko.cn/npm/katex@0.16.4/dist/katex.min.js"></script>
      
        <script src="https://unpkg.com/katex@0/dist/contrib/auto-render.min.js"></script>
      
    
  <script id="init-glightbox">const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});
document$.subscribe(() => { lightbox.reload() });
</script></body>
</html>